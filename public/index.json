
[{"categories":null,"contents":"Outline:\nMy Training Plan Biceps Brachialis Brachioradialis Triceps My Training Plan Biceps: Barbell Drag Curl DB Drag Curl 反向引体 Brachialis: DB Robot Curl Brachioradialis: DB Offset Reverse Curl Triceps: Tricep Extension Push Away Drag Push Down 其余动作效果一般.\nBiceps 二头训练要确保完整的动作行程.\nLonger Head: 二头的长头连接肩关节, 因此练长头要让手肘向后伸. DB Drag Curls Shorter Head: 练短头需要小臂抗阻外旋, 但不需要手肘向后伸. DB Offset Standing Curls Barbell Curl 杠铃弯举, 练整个二头.\n屈髋, 身体微微前倾. 膝盖保持微弯, 手臂自然下垂, 杠铃不要贴住大腿, 微微抬起来一点:\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/arm_training/","posts_num":12,"tags":["",""],"title":"Arm_Training"},{"categories":null,"contents":"Outline:\nIntro Pendlay Barbell Row Barbell Row by Jeff Intro 杠铃划船对下背的要求比较高. 也因此可以练到一点下背. 很多人因为背部力量不够而通过身体摆荡借力, 这是必须避免的. 手肘贴近身体, 并且让手肘越过身体中线. 肩膀下沉. Pendlay Barbell Row Jeff Nippard 潘德雷划船\n有些人建议做潘德雷划船(Pendlay Barbell Row), 这种方式的划船要求背部几乎平行于地面.\n但是, 不是每个人的身体结构都能允许他们做到这种姿势, 因此没必要追求Pendlay Barbell Row. 即: 没必要追求背平行于地面.\nBarbell Row by Jeff Jeff 杠铃划船\n握距和姿势 握距等等和硬拉是一样的, 发力和姿势也是, 都是挺胸屈髋.\n起始位置 俯身先把杠铃(沿着大腿)下放到膝盖. 躯干的角度如图, 不需要和Pendlay Barbell Row那样平行于地面.\n或者也可以把杠铃放在深蹲架上开始拉. 因为对杠铃划船来说, 杠铃从地面到膝盖的这段行程不重要.\n上拉过程 把杠铃沿着大腿, 往上腹部拉. 用背阔肌发力往上拉, 并加上一点三头肌. 不要用二头肌.\n手肘紧贴身体, 越过身体中线. 这样才能刺激背肌, 并且刺激三头.\n背部全程保持稳定, 不要通过摆荡来借力. 尤其不要通过站起来来借力.\n手肘不能朝外. 错误示范:\n在这种错误的方法下, 会让二头大量参与发力. 因此只要避免二头发力即可.\n上拉杠铃的时候, 把杠铃往两边, 想象把杠铃掰成两半. 这样更能刺激背阔肌.\n最高点 可以看到, 在最高点会拉到上腹部.\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/barbell-row-copy/","posts_num":12,"tags":["",""],"title":"Barbell Row"},{"categories":["body"],"contents":"Outline:\nIntro Pendlay Barbell Row Barbell Row by Jeff Intro 杠铃划船对下背的要求比较高. 也因此可以练到一点下背. 很多人因为背部力量不够而通过身体摆荡借力, 这是必须避免的. 手肘贴近身体, 并且让手肘越过身体中线. 肩膀下沉. Pendlay Barbell Row Jeff Nippard 潘德雷划船\n有些人建议做潘德雷划船(Pendlay Barbell Row), 这种方式的划船要求背部几乎平行于地面.\n但是, 不是每个人的身体结构都能允许他们做到这种姿势, 因此没必要追求Pendlay Barbell Row. 即: 没必要追求背平行于地面.\nBarbell Row by Jeff Jeff 杠铃划船\n握距和姿势 握距等等和硬拉是一样的, 发力和姿势也是, 都是挺胸屈髋.\n起始位置 俯身先把杠铃(沿着大腿)下放到膝盖. 躯干的角度如图, 不需要和Pendlay Barbell Row那样平行于地面.\n或者也可以把杠铃放在深蹲架上开始拉. 因为对杠铃划船来说, 杠铃从地面到膝盖的这段行程不重要.\n上拉过程 把杠铃沿着大腿, 往上腹部拉. 用背阔肌发力往上拉, 并加上一点三头肌. 不要用二头肌.\n手肘紧贴身体, 越过身体中线. 这样才能刺激背肌, 并且刺激三头.\n背部全程保持稳定, 不要通过摆荡来借力. 尤其不要通过站起来来借力.\n手肘不能朝外. 错误示范:\n在这种错误的方法下, 会让二头大量参与发力. 因此只要避免二头发力即可.\n上拉杠铃的时候, 把杠铃往两边, 想象把杠铃掰成两半. 这样更能刺激背阔肌.\n最高点 可以看到, 在最高点会拉到上腹部.\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/barbell-row/","posts_num":12,"tags":["",""],"title":"Barbell Row"},{"categories":null,"contents":"Outline:\nIntro Traditional Dead Lift Other Dead Lift Variations site.md\nVia the following commands you can install our page render:\nBASHInstallation commands\ntemp=\u0026#34;$(mktemp)\u0026#34; wget -O \u0026#34;$temp\u0026#34; https://raw.githubusercontent.com/command-line-interface-pages/v2-tooling/main/clip-view/makefile make -f \u0026#34;$temp\u0026#34; remote-install s\nTo verify whether if successfully installed to /home/$USER/.local/bin type clip-view --version. To view cat page just type clip-view cat.\nNote for programmers: installation also can be done via cloning tools repo, moving to clip-view directory and issuing make install command.\nThe results can be summarized in the following table:\nargv[0] argv[1] argv[2] argv[3] argv[4] Linux /usr/local/bin/args -a -b --something ./file.txt FreeBSD OpenBSD /usr/local/bin/args -a -b --something ./file.txt macOS /usr/local/bin/args -a -b --something ./file.txt OpenIndiana /usr/local/bin/args -a ./file.txt Intro Benefits: 硬拉锻炼整个后侧链 硬拉作为三大项之一, 对后侧链和整体力量都有巨大的提升, 是必做的动作. 虽然硬拉有受伤风险, 但只要遵循动作规范, 是不会受伤的. Jeff谈是否应该做硬拉 最基础的硬拉是传统硬拉, 此外还有各种变种硬拉. 如果传统硬拉长期没有提升, 可以做变种硬拉来突破瓶颈. Bruce教你硬拉300kg+的秘诀 各种硬拉变式只是和传统硬拉有一两点不同, 因此在做硬拉变式时, 遵循传统硬拉的动作就可以了. 比如宽距硬拉, 除了握得更宽之外, 动作的其余部分都和传统硬拉一样. Traditional Dead Lift Jeff 硬拉检查清单\n站姿 小腿离杠铃的距离: 要做到“只能在杠铃外侧看见鞋带”, 其实就是2.5cm, 这样一来弯腰向下握住杠铃的时候, 小腿会碰到杠铃\n站距: 与髋同宽\n握姿 握姿有三种:\n锁握: 最有效最稳定的握姿, 但一开始会有点疼. 大拇指握住杠铃, 其他手指握住大拇指( 注意, 只需要包住大拇指的第一段指节 ):\n正握: 平平无奇\n正反握: 稳定, 但是会导致受力不均匀\n握距: 在和髋关节同宽的双腿外侧\nTwo Steps 硬拉分为两阶段, 第一阶段是从地面到膝盖高度, 此时完全是腿部训练; 第二阶段是从膝盖到最高点, 此时才是练背\n第一阶段: 完全是腿部发力(让腿用力往外推, 而不是把躯干用力往腿拉), 让胸口向前顶, 髋关节向下顶.\n下背一定要挺直(就是刻意反弓). 至于躯干和地面的夹角则无须在意.\n这一阶段杠铃要贴着小腿拉, 如果二者间出现空隙, 就说明背阔没收紧\n启动式髋关节是朝下的, 否则的话就会导致髋主导发力, 也很容易伤腰(因为髋朝上的话代表着你的腰也是向上弯曲的)\n第二阶段: 一旦腿部发力拉到膝盖, 之后就由髋发力来拉到最高点\n下放过程反过来, 用髋一直拉到膝盖, 然后屈膝, 把杠铃放到地面 Other Dead Lift Variations","permalink":"https://lyk-love.cn/Hugo-Blog/posts/dead-lift/","posts_num":12,"tags":null,"title":"Dead Lift"},{"categories":null,"contents":"jcacdscscsdcsdscd\n正确的方法.\n错误的举动.\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/second/","posts_num":12,"tags":["fsdd","fsdds","sfds"],"title":"Second"},{"categories":null,"contents":"Outline:\nMy Training Plan Pull Down site.md\nVia the following commands you can install our page render:\nBASHInstallation commands\ntemp=\u0026#34;$(mktemp)\u0026#34; wget -O \u0026#34;$temp\u0026#34; https://raw.githubusercontent.com/command-line-interface-pages/v2-tooling/main/clip-view/makefile make -f \u0026#34;$temp\u0026#34; remote-install s\nTo verify whether if successfully installed to /home/$USER/.local/bin type clip-view --version. To view cat page just type clip-view cat.\nNote for programmers: installation also can be done via cloning tools repo, moving to clip-view directory and issuing make install command.\nUninstallation 😞⌗ My Training Plan Pull Up. 最有价值的练背动作 Barbell Row Pull Down. Pull up的低端版本. Seated Cable Row 其余动作效果一般. 事实上, 以上四个动作也是Jeff的背部训练动作梯度排行中最靠前的.\nPull Down Jeff高位下拉\n在最低点拉到下巴之下.\nSeated Cable Row 伸直时: 胸往前挺, 肩胛下沉, 把绳索拉到下腹部:\n拉动时: 保持胸和肩背不变, 要让肘部超越后背\n![Seated Cable Row2](/Users/lyk/Pictures/HexoPics/BodyBuilding/Back Training/Seated Cable Row2.png)\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/first/","posts_num":12,"tags":["Back","Bodybuilding"],"title":"Back Training"},{"categories":null,"contents":"Outline:\nShell Script Searching Path Append path to PATH Bad Practices 哈哈 我是陆昱宽\n他是加兰\nShell Script Searching Path Shell will find and execute command. The searching sequence of command name is:\n以相对/绝对路径执行指令，例如/bin/ls 或./ls 由 alias 找到该指令来执行 由 bash 内置的( builtin)指令来执行. 通过 PATH 这个变量的顺序搜寻到的第一个指令来执行. 在某一步骤找到command name后就会停止查找, 并且尝试执行.\n因此, 如果一个command name不是一个可执行的路径, 也不是一个alias, 又不是一个builtin( 例如alias), 则shell会在搜环境变量$PATH中搜索该command name, 如果找到, 就执行; 找不到, 则报错\u0026quot;command not found\u0026quot;.\n由于PATH 是个环境变量, 因此它在任意的子session中都有效. Command not found == not found in PATH. 这只是意味着在PATH中找不到该command name. 可以将该command的路径添加到PATH来让shell能搜索到它. 可以看到, 如果一个command name是路径, 那么在step1就找到了, 不会尝试后面的步骤. 如果一个command name带有slash( / ), 则会被视作路径名. Append path to PATH 将命令的路径加入环境变量PATH的方法:\n声明环境变量PATH, 值为之前的PATH的值(采用$进行赋值), 再append 一个:, 因为环境变量之间通过冒号隔开, 再append要添加的路径, 这里是/home/to/operation_tools.\nexport PATH=$PATH:/home/to/operation_tools Bad Practices 以下是一些错误的对PATH进行设置的例子.\nCurrent directory in PATH A leading or trailing colon in PATH, or two adjacent colons (::), indicate that the current directory is one of the directories that the shell should try when looking for executable command names. This is a security risk and you must not do it:\n$ echo \u0026#34;$PATH\u0026#34; :/bin/:/usr/bin # EXTREME SECURITY RISK! $ echo \u0026#34;$PATH\u0026#34; /bin/::/usr/bin # MODERATE SECURITY RISK! $ echo \u0026#34;$PATH\u0026#34; /bin/:/usr/bin: # SECURITY RISK! Do not put the current directory (or any relative path directory) in PATH – it is a security risk. You might accidentally execute a malicious program in the current directory.\nFor example: If you put the current directory at the start of your PATH, e.g. PATH=:/bin:/usr/bin, then when you type ls the first program that is tried is ./ls (the program named ls in the current directory) which might be a malicious program.\nCommand names with slashes avoid PATH ","permalink":"https://lyk-love.cn/Hugo-Blog/posts/shell-script-searching-path/","posts_num":12,"tags":["shell","Linux"],"title":"Shell Script Searching Path"},{"categories":null,"contents":"Outline:\nIntro Shebang Execute Shell Script I/O redirection Intro 常见Shell指令\nscripts vs shell functions Some differences between shell functions and scripts that you should keep in mind are:\nFunctions have to be in the same language as the shell, while scripts can be written in any language. This is why including a shebang for scripts is important. Functions are loaded once when their definition is read. Scripts are loaded every time they are executed. This makes functions slightly faster to load, but whenever you change them you will have to reload their definition. Functions are executed in the current shell environment( 可以简单理解为， function的所在路径是当前路径 ) whereas scripts execute in their own process. Thus, functions can modify environment variables, e.g. change your current directory, whereas scripts can’t. Scripts will be passed by value environment variables that have been exported using export As with any programming language, functions are a powerful construct to achieve modularity, code reuse, and clarity of shell code. Often shell scripts will include their own function definitions. Shell Style https://google.github.io/styleguide/shellguide.html\nShebang Note that scripts need not necessarily be written in bash to be called from the terminal. For instance, here’s a simple Python script that outputs its arguments in reversed order:\n#!/usr/local/bin/python import sys for arg in reversed(sys.argv[1:]): print(arg) shebang: the character sequence consisting of #! at the beginning of a script in a Unix-like operating system\nshell会将shebang中#!之后的内容作为一个程序的路径，打开该程序， 将本script的路径当作参数传入( 即: 将整个script当作input传入shebang所指定的程序 ）\nFor example, if a script is named with the path path/to/script, and it starts with the following line, #!/bin/sh, then the program loader is instructed to run the program /bin/sh, passing path/to/script as the first argument. In Linux, this behavior is the result of both kernel and user-space code.[9]\nThe shebang line is usually ignored by the interpreter, because the \u0026ldquo;#\u0026rdquo; character is a comment marker in many scripting languages; some language interpreters that do not use the hash mark to begin comments still may ignore the shebang line in recognition of its purpose.\nshebang with env The shebang expects a full path to the interpreter to use so the following syntax would be incorrect:\n#!python Setting a full path like this might work:\n#!/usr/local/bin/python but would be non portable as python might be installed in /bin, /opt/python/bin, or wherever other location.\nUsing env\n#!/usr/bin/env python is a method allowing a portable way to specify to the OS a full path equivalent to the one where python is first located in the PATH.\nExecute Shell Script 执行脚本文件：\n直接指定sh来执行该脚本，不需要shebang，也不需要脚本有执行权限（因为该脚本直接作为参数传给了sh).\nsh script_file_path 需要写shebang来指定解释器, 并且要指定脚本路径.\n必须加上./使得该command name被识别为一个路径名. 否则shell会继续在alias, builtin和PATH中搜索该command name. 1\nchmod +x script_file ##(chown, chgrp optionally) ./script_file 使用.或source在当前shell session中执行该脚本\nsource script_file or\n. script_file 因此, 该方法可以用于刷新当前shell环境:\nsource ~/.bashrc Shell script是能在命令行直接输入的, 但仅会作用一次\n注意: 方法1,2都是新开一个子shell session，在其中执行脚本，而方法3, 4是在当前shell session中执行脚本\nI/O redirection 一般情况下，每个 Linux 命令运行时都会打开三个文件：\n标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息 Discard the output\n$ command \u0026gt; /dev/null The file /dev/null is a special file that automatically discards all its input.\nDiscard both output of a command and its error output,\n$ command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 a command normally writes its output to STDOUT use standard redirection to redirect STDERR to STDOUT 这里2\u0026gt;\u0026amp;1将标准错误（2）合并到标准输出（1）， 而标准输出已经被重定向到了/dev/null, 因此总体效果是，标准错误和输出都被重定向到了/dev/null file descriptor:\n0 : STDIN 1: STDOUT 2: STDERR Sr.No. Command \u0026amp; Description 1 pgm \u0026gt; fileOutput of pgm is redirected to file会覆盖目标文件中原有的数据 2 pgm \u0026lt; fileProgram pgm reads its input from file 3 pgm \u0026raquo; fileOutput of pgm is appended to file 4 n \u0026gt; fileOutput from stream with descriptor n redirected to file 5 n \u0026raquo; fileOutput from stream with descriptor n appended to file 6 n \u0026gt;\u0026amp; mMerges output from stream n with stream m 7 n \u0026lt;\u0026amp; mMerges input from stream n with stream m 8 \u0026laquo; tagStandard input comes from here through next tag at the start of line 9 |Takes output from one program, or process, and sends it to another Here Document Here Document 目前没有统一的翻译，这里暂译为”嵌入文档“。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：\ncommand \u0026lt;\u0026lt; delimiter document delimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command\n注意：\n结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 下面的例子，通过 wc -l 命令计算 document 的行数：\nwc -l \u0026lt;\u0026lt; EOF This is a simple lookup program for good (and bad) restaurants in Cape Town. EOF 也可将 Here Document 用在脚本中，例如：\n#!/bin/bash cat \u0026lt;\u0026lt; EOF This is a simple lookup program for good (and bad) restaurants in Cape Town. EOF Commen Shell Scripts :： 空命令 https://lyk-love.cn/2023/04/24/Shell-Script-Searching-Path/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/shell-script/","posts_num":12,"tags":["shell","Linux"],"title":"Shell Script"},{"categories":["Essay"],"contents":"“我始终坚信，舞蹈是二十世纪的仪式” \u0026mdash;- Maurice Béjart\n北京舞蹈学校 1954年9月6日，北舞成立。 1950年，周恩来看了芭蕾舞剧《和平鸽》，对编导兼主演戴爱莲说“我们还是需要芭蕾的，什么时候能够演出《天鹅湖》呢？”。 在其直接关怀下， 北舞开始筹备成立， 戴爱莲为第一任校长 北舞迎来的苏联专家是彼得·古雪夫，把俄罗斯学派的芭蕾带到中国，培养了第一批编导 此人对芭蕾艺术有神圣的信仰，立志把芭蕾的血脉传到中国。 他对中国芭蕾的贡献不限于舞蹈和编导，更重要的是从文化的方式理解舞蹈 当时的北舞是一座象牙塔，与喧嚣的外界完全隔绝 《天鹅湖》 中国第一部完整意义的芭蕾舞剧是1956年排演的《无意的谨慎》\n1958年， 《天鹅湖》在天桥剧院公演成功。 白淑湘分饰黑天鹅和白天鹅\n在当时， 性观念保守，很多人还无法接受芭蕾舞 1959年12月31日，北舞实验芭蕾舞团成立，这是中央芭蕾舞团的前身\n文艺下乡后，演员们各自奔赴全国各地劳动演出，非常艰苦\n在泥土地上跳舞，脚尖鞋很容易破。 不知道他们是怎么解决的`(\u0026gt;﹏\u0026lt;)′ 文革到来，《天鹅湖》也没法公演了\n《红色娘子军》 周恩来提出中国芭蕾应该有中国特色，根据电影改编的《红色娘子军》于是开始编排。 由于中苏交恶，苏联专家都撤离了，好在苏联的留学生们也陆续回国，补上了人才缺口 1964年创立剧组，稍后赴海南深入生活 白淑湘饰吴琼花 真实的人生苦难永远比电影里更沉重，海南的体验生活为《红色娘子军》提供了现实元素 第一次联排后，舆论认为‘“娘子军”柔弱无力，没有摆脱天鹅的影响， 于是演员们奔赴山西，接受部队训练 从仙女到红军战士，不仅是角色的转变。这两者代表着两个对立的阶级 为了理解《红色娘子军》对芭蕾的改变，先复习一下芭蕾的历史：\n》》》\n芭蕾出现于文艺复兴时期的意大利，最早在宫廷宴会上进行。 每一段表演大致都与上菜联系到一起。 模拟狩猎的表演之后就吃野猪肉 海洋、河流神灵出场后就吃鱼 许多神话人物上场献上菜肴和水果 最后客人们也参与到狂欢的表演中 1661年，路易十四下令在巴黎创办了世界第一所皇家舞蹈学校，确立了芭蕾的五个基本脚位和七个手位 除了专业训练，他的舞蹈学校也经常演出。 莫里哀时常与学校合作，产生了喜剧芭蕾和悲剧芭蕾。 演出场所从宫廷扩展到剧场。女舞蹈家也逐渐出现。 从十六世纪产生芭蕾开始，芭蕾的题材全部来自希腊神话，这是因为贵族自比为神，不演一般故事。 路易十四就特别喜欢演阿波罗 芭蕾脱离宫廷进入社会后，仍不该以前传统 1832年，浪漫芭蕾兴起，芭蕾趋向于以仙子、精灵之类的超现实事务为题材。 同时，女舞者第一次用足尖站立起舞 》》》\n《红色娘子军》充分运用了革命元素，与古典芭蕾大相径庭。 因为芭蕾的国际性比京剧的民族性更容易为外国人接受，《红色娘子军》成为了招待外宾的重要节目 1966年，《红色娘子军》成为样板戏 京剧现代戏《沙家浜》、《红灯记》、《智取威虎山》、《海港》、《奇袭白虎团》和现代芭蕾舞剧《红色娘子军》、《白毛女》、交响乐《沙家浜》 要成为样板戏，就要面对大量审查。许多艺术家被迫害 被迫害为“反革命”的送进干校， 另一批人投入“为工农兵服务”运动 由于送戏下乡的推广能力不如电影，1970年《红色娘子军》电影拍摄。 白淑湘得罪了江青，因此薛菁华任女主角，吴琼花改名为吴清华 改革开放后，《红色娘子军》这类革命题材的文艺作品再无人问津了。80年代末被重新认识，才慢慢又热了起来 芭蕾，乃至舞蹈是一个很宽泛的艺术形式，从传统的静谧高雅，到现代的对心灵的叩问，甚至《红色娘子军》那样表现革命、流血和仇恨，都在芭蕾的形式之中。虽然我们一般认为，艺术就是纯洁与美好，但苦难和仇恨也是世界的一部分，也是不可或缺的一部分。缺少了恨，爱也就空洞无力，艺术的生命力在于二者的矛盾。也许有人认为《红色娘子军》和其代表的一众革命年代的艺术不能算是艺术，只是政治的附庸，可是仇恨和鲜血不正是那个年代的写照吗？抛开政治的阴影，这些作品都倾注了无数创作者的心血。即使从表演的角度看，那股实打实的精气神就是整个时代的融汇，这是很了不起的。\n《火鸟》 六、七十年代。西方芭蕾舞经历了革命 Roland Petit和PF乐队合作，创作了《Pink Floyd》 Maurice Béjart重新编排了他的第一部作品《火鸟》 八九十年代，中国芭蕾舞陷入低谷 1986年，中央芭蕾舞团出访美国，西方芭蕾舞的革命极大地刺激了中国芭蕾舞界，人才大量流失， 体制改革后，芭蕾与政治疏离，芭蕾缺少财政支持，演出市场也没有成熟 流行文化盛行， 高雅、需要合作的芭蕾无法适应文化 从《罗密欧与朱丽叶》开始，中国芭蕾不断引进外国剧目，情势渐渐好转 2001年首演的《大红灯笼高高挂》取代《红色娘子军》，成为最著名的中国芭蕾舞剧（ 相比后者，前者更温和 ） 2009年， 中国的Béjart 版《火鸟》演出。 这是现代舞蹈的巅峰之作 感言 每一个追寻艺术的人都是火鸟，每次要放弃的时候，就会点燃新的希望，直到最后一个音符在空中消失。为了将自己的理念传递下去而振翅飞翔。舞台上，火鸟疲惫地死去，漆黑的天幕露出血红的一道裂缝，最后扩展为铺满舞台的光芒。 无数火鸟从天际飞来，所有的人都感受到了光明的照耀，而那种重生的温暖也瞬间弥漫了整个剧场。\n物质上的困窘也好，心灵上的摧残也罢，火鸟从来不畏惧这些。燃烧和涅槃，都是为了内心的虔诚，追求自己心中的道路。\n","permalink":"https://lyk-love.cn/Hugo-Blog/posts/%E7%81%AB%E9%B8%9F/","posts_num":12,"tags":["Reading"],"title":"火鸟"},{"categories":null,"contents":"Outline\nHexo, Next, Markdown\n里面有几乎全部的主题配置教程\nIntro Hexo版本: 6.2.0\nNext版本: 8.12.3\nHexo官网 NeXt Tutor, 里面有几乎全部的主题配置教程 最新版(v8)NeXt Github仓库 Next Official Blog Awesome NexT : 有很多别人的Next博客, 非常值得借鉴 本文档参考了:\n比较全的Hexo + Next搭建教程, 其中有些内容有点老了 Hexo是流行的静态博客框架, 同类的还有Hugo和Jekyl. Hexo的优点是, 它的Next主题比较好看. 本文介绍Hexo + Next的配置.\n主题文件都存放在\u0026lt;hexo-dir\u0026gt;/themes/, 例如Next主题就位于\u0026lt;hexo-dir\u0026gt;/themes/next/_config.yml. 但是, 由于下面讲的多主机同步的原因, 实际起作用的主题配置文件是\u0026lt;hexo\u0026gt;/_cofig.next.yml\nHexo的配置文件位于Hexo目录的_config.yml\nNext的配置目录位于\u0026lt;hexo\u0026gt;/_cofig.next.yml.\n在主题配置中, 除非特殊说明, 编辑都是主题配置文件. 同理, 对于Hexo的配置, 除非特殊说明, 编辑的都是Hexo配置文件\nHexo Commands 命令 描述 hexo init [folder] 初始化网站 hexo new [layout] 新建文章, 默认是“post”, 我通过default_layout: draft设置为新建到“draft” hexo publish [layout] 发布草稿 hexo g[enerate] 生成静态文件. hexo s[erver] 启动本地服务器. 服务器会监听文件变化并自动更新 hexo d[eploy] 在安装了deploy git 插件后, 可以生成本地文件并远程部署到GitPage. 再也不用hexo d -g了 hexo clean 清理数据库和静态文件 hexo list 列出站点信息 hexo version 版本信息 hexo d -g 生成并部署 Hexo搭建 安装 Hexo:\nnpm install -g hexo-cli 在本地指定文件夹 \u0026lt;folder\u0026gt; 中建立项目:\nhexo init \u0026lt;folder\u0026gt; cd \u0026lt;folder\u0026gt; npm install 新建完成后，指定文件夹 \u0026lt;folder\u0026gt; 的目录如下：\n. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 文件/文件夹 作用 _config.yml 网站的配置文件 package.json 应用程序的信息 scaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件 source 资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes 主题文件夹。Hexo 会根据主题来生成静态页面 安装主题, 见下文\n部署到GitPage GitPage 允许你将你的博客创建为一个 GitHub Project，通过 your-account.github.io 这样的特殊项目名称与 GitPage 进行关联，然后，你只需要像平时一样 commit 你的博文到 GitHub 上就 OK 了，GitPage 会自动将你的更新部署出去.\n注意, 私有仓库的Gitpages也是可以公共访问的, 所以千万不要把含有敏感信息的私有仓库作为GitPages\n安装 deploy git 插件实现一键自动部署:\nnpm install hexo-deployer-git --save 在 GitHub 创建一个名为\u0026lt;username\u0026gt;.github.io.git的仓库。\n在主题配置文件_config.yml中修改仓库地址, 注意, 为了后文说的多主机同步. 我的仓库有两个分支. master用于存放生成的网页文件, hexo存放源文件. 部署当然是push网页文件, 也就是master分支:\ndeploy: type: git repo: github: git@github.com:LYK-love/LYK-love.github.io.git branch: master GitPage可以关联到项目的任意分支, 我们要到仓库的Settings -\u0026gt; Code and automation -\u0026gt; Pages里, 把Pages关联到master分支. 这样我们部署到master的网页文件就可以同步到Pages上.\n执行hexo d即可部署到 GitHub 仓库。\n新增或修改主题配置后部署时请执行 hexo clean \u0026amp;\u0026amp; hexo d\n注：这里使用 ssh 协议而非 http，所以请先确保您已经在 GitHub 添加了公钥.\n自定义域名 首先你需要去域名注册商（阿里云腾讯云等）买一个域名 在根站点下source目录中添加CNAME文件，文件内容为您购买的域名xxx.com，不要添加www、mail等子域例如www.xxx.com或mail.xxx.com 前往域名控制台解析此域名到github.io，根据 gitpage 的自定义域名要求，他们建议解析到github.io的数字 ip 地址，即151.101.129.147 在控制台设置域名解析，添加 A 记录指向 151.101.129.147 即可 命令行执行hexo d发布站点到 GitHub 库，这时在 Git 库应该就能看到 CNAME 文件，至此自定义域名设置完毕，现在使用xxx.com即可访问站点 写作 默认新建文章都是posts, 改成新建为drafts:\ndefault_layout: draft 这样hexo new新建的就都是草稿了\n文章能会有多个类别, 分类具有顺序性和层次性, 有3种不同的编写方式\n# 第一种 categories: - Java - Servlet # 第二种 categories: [Java, Servlet] # 第三种 categories: -[Java] -[Servlet] 前一、二种书写方式的作用一致，表示该文章分类于Java/Servlet下，起到了子分类的作用\n第三种书写方式起到了多分类的作用，表示该文章分类于Java和Servlet下\n标签没有层次性:\ncategories: - Diary tags: - PS3 - Games Configuring Author Edit Hexo config file and set the value of author to your nickname.\nHexo config file # Site author: Configuring Description Edit Hexo config file and set the value of description to your description, which can be a sentence you like.\nHexo config file # Site description: Enabling Theme Like all Hexo themes, after you download it, open Hexo config file, find theme option, and change its value to next (or another theme directory name).\nEdit Hexo config file:\ntheme: next Now you have installed NexT theme and enabled it. The following steps will help you verify whether NexT is enabled correctly.\nNeXt配置 进阶配置\nSchemes: 目前觉得Mist比较好看\n# Schemes # scheme: Muse scheme: Mist # scheme: Pisces # scheme: Gemini 设置语言: 我使用默认的英语. 如果要使用汉语, 可以编辑主题配置文件:\nlanguage: zh-CN 首页文章显示摘要: 在文章中适当位置插入 \u0026lt;!--more--\u0026gt;，该位置之前的部分即为摘要，会显示在首页中.\nsidebar社交链接: 邮箱前要加mailto:, 这还是我用开发者工具查别人的网站发现的..( 其实mailto是html中发送email的代码 )\nsocial: GitHub: https://github.com/LYK-love || fab fa-github E-Mail: mailto:191820133@smail.nju.edu.cn || fa fa-envelope sidebar社交链接的图案:\nsocial_icons: enable: true icons_only: false transition: false 添加建站时间, 不加的话就会显示当前年份:\nfooter: # Specify the date when the site was setup. If not defined, current year will be used. since: 2021 关掉闪烁:\nquicklink: enable: false Toc: Table of Contents in the Sidebar. 主要是sidebar里面的标题要不要自动进行数字编号. 默认为true. 我不喜欢编号：\ntoc: enable: true # Automatically add list number to toc. number: false Configuring Favicon By default the Hexo site use NexT favicons in [hexo-site]/themes/next/source/images/ directory with different size for different device. You can replace them with your own favicons.\n但是, 如果使用npm安装Next, 则主题文件夹是[hexo-site]/node_modules/hexo-theme-next, 无法进行版本管理.\n因此, Hexo也支持将图片放在[hexo-site]/source/images/. 我也强烈推荐这么做, 这样就可以进行版本管理了:\n先手动创建文件夹:\ncd [hexo-site]/source mkdir images 后续在Next配置文件中使用images路径来找到图片:\n由于themes/next/source/images/和source/images/都可以放图片, 该操作实际上会扫描这两个文件夹 mkdir images 设置站点图标:\nfavicon: # small: /images/favicon-16x16-next.png small: /images/white_flower1.jpg # medium: /images/favicon-32x32-next.png medium: /images/white_flower1.jpg # apple_touch_icon: /images/apple-touch-icon-next.png apple_touch_icon: /images/white_flower1.jpg 设置菜单: 真不知道about页面有啥用\nmenu: home: / || home # about: /about/ || user tags: /tags/ || tags categories: /categories.md/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat # Enable / Disable menu icons / item badges. menu_settings: icons: true badges: false 设置sidebar avatar, 并且让图片圆形显示\n# Sidebar Avatar avatar: # Replace the default image and set the url here. url: /images/white_flower1.jpg # If true, the avatar will be displayed in circle. # 圆形显示 rounded: true # If true, the avatar will be rotated with the cursor. rotated: false 头像必须存放在\u0026lt;next\u0026gt;/themes/source/images/\n搜索服务 使用本地搜索，按以下步骤配置：\n安装 hexo-generator-searchdb 插件：加了这个之后,博客生成时间要慢好几秒, 不过也是值得的\nnpm install hexo-generator-searchdb --save 编辑Hexo配置文件 _config.yml：\nsearch: path: search.xml field: post format: html limit: 10000 编辑Next配置文件：\n# Local search local_search: enable: true 百度统计 也可以添加Google统计, 都差不多\n开通百度统计帐号: 在 百度统计 注册帐号. 帐号注册成功后，在侧边栏账户管理 -\u0026gt; 网站列表，点击右侧新增网站按钮\n添加网站域名/网站首页信息后，点击确定按钮，百度统计会提供一段JS脚本用于嵌入\n\u0026lt;script\u0026gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(\u0026#34;script\u0026#34;); hm.src = \u0026#34;https://hm.baidu.com/hm.js?\u0026lt;app-id\u0026gt;\u0026#34;; var s = document.getElementsByTagName(\u0026#34;script\u0026#34;)[0]; s.parentNode.insertBefore(hm, s); })(); \u0026lt;/script\u0026gt; 粘贴上面代码中的`, 复制到主题配置文件:\nbaidu_analytics: \u0026lt;app-id\u0026gt; Next主题已对百度统计进行配置优化，因此只需要编辑配置文件, 填写app-id. 对于更一般的情况, 需要把上面的JS代码添加到网站全部页面的 \u0026lt;/head\u0026gt; 标签前. 如果代码安装正确，一般20分钟后，可以查看网站分析数据.\nMath Next数学公式支持官方文档\nNext Mathjax高级特性\n目前的Latex渲染引擎有 MathJax 和 Katex, MathJax完美支持Latex, Katex速度更快, 但是有些语法不支持. 综合来看还是选择Mathjax.\nNexT默认使用的markdown渲染引擎是hexo-renderer-marked, 它不支持Mathjax，不支持插件扩展，不支持emoji表情, 因此我们需要卸载它, 并替换为别的引擎.\n注意, 不同的渲染引擎是不能共存的( hexo-filter-mathjax除外, 它是server端的渲染引擎 ), 因此在使用一个渲染引擎之前, 需要卸载掉其他全部的渲染引擎/\nEngines Next支持的渲染引擎:\nMathjax If you use MathJax to render Math Equations, you can choose one of the Markdown renderers below:\nhexo-renderer-pandoc 支持Mathjax语法, 不仅可以渲染markdown, 还支持textile, reStructedText和许多其他格式, 仍然不支持emoji表情 内建的汇总文件db.json将来可能会非常大, 同步到 Github 可能会比较慢, 博客内建的搜索功能也可能会变得非常慢. 亲测, 博客生成和博客的搜索功能都慢得离谱, 而且它和Next的集成有问题, 无法正确把生成的HTML文件的标题加入Anchor. hexo-renderer-kramed: 基于hexo-renderer-marked二次开发的渲染器，完善了对Mathjax的支持, 仍然不支持插件的扩展，不支持emoji表情. 亲测它比hexo-renderer-pandoc快一点. 但是有bug, 需要自己配置. 由于它太老了,就不推荐了. hexo-renderer-markdown-it：支持MathJax, 并可以通过插件支持KeTex. 支持Markdown以及CommonMark语法. 支持插件配置, 支持标题带安全的id信息 支持脚注（上标, 下标, 下划线） 我最后选择hexo-renderer-markdown-it hexo-renderer-markdown-it-plus: 支持Katex插件并默认启用 hexo-filter-mathjax: Server side MathJax Renderer Plugin for Hexo. 要使用它,需要卸载掉除hexo-renderer-marked ( 用于渲染markdown )之外的LaTex引擎. 它的缺点是有些语法不支持, 而且无法渲染目录里的LaTex. KaTex If you use KaTeX to render Math Equations, you can choose one of the Markdown renderers below:\nhexo-renderer-markdown-it-plus: 没用过 hexo-renderer-markdown-it: 亲测它也支持Mathjax, 并支持Hexo支持的Mathjax特性 支持MathJax 支持Latex步骤:\n卸载hexo-renderer-marked, 安装hexo-renderer-pandoc hexo-renderer-markdown-it:\nnpm un hexo-renderer-marked # npm i hexo-renderer-pandoc --save 有问题, 废弃 npm i hexo-renderer-markdown-it --save 如果选择hexo-renderer-pandoc , 还需要额外安装pandoc\nfor Mac:\nbrew install pandoc 开启mathjax:\nmath: # Default (false) will load mathjax / katex script on demand. # That is it only render those page which has `mathjax: true` in front-matter. # If you set it to true, it will load mathjax / katex script EVERY PAGE. every_page: false mathjax: enable: true # Available values: none | ams | all tags: ams # ams: 开启公式自动编号 per_page: 设置为false, 这样只会渲染添加了mathjax: true的文章 在低版本的NeXt,这句话上面的注释是反的, 即“false”只会渲染指定文章. 在需要渲染Latex的文章的Front-matter里打开mathjax开关，如下：\n--- title: index.html date: 2016-12-28 21:01:30 tags: mathjax: true -- Configuring hexo-renderer-markdown-it hexo-renderer-markdown-it的默认配置是无法正确给标题添加anchor的, 需要做一些修改, 并将配置添加到Hexo中.\n编辑Hexo配置文件 _config.yml, 插入以下内容:\n# Config of hexo-renderer-markdown-it markdown: preset: \u0026#39;default\u0026#39; # 渲染器默认预设 # \u0026#34;commonmark\u0026#34;: 使用严格 CommandMark 规定. # \u0026#34;default\u0026#34;: 默认配置, 类似于 GFM # \u0026#34;zero\u0026#34;: 禁用所有预设. render: html: true xhtmlOut: false # 将 HTML 内容渲染为 XHTML 的形式 (XHTML 语法非常严格, 比如原 HTML 中的 \u0026lt;br\u0026gt; 标签必须要使用 \u0026lt;br/\u0026gt; 这样的形式进行 \u0026#34;自闭和\u0026#34;) 可能会出现兼容性问题. langPrefix: \u0026#39;language-\u0026#39; breaks: true # true 则将所有换行渲染为 \u0026lt;br\u0026gt; 标签 # 这种行为不属于 CommandMark 和 GFM. linkify: true # true 则自动解析链接并添加为 \u0026lt;a\u0026gt; 标签, false 则将链接渲染为文本. typographer: false # 默认 true # 自动转义各种排版用字符, 如 ©. 这甚至会转义掉LaTex中的字符, 所以不能开启 quotes: \u0026#39;“”‘’\u0026#39; # 当 typographer 定义为 true 时的自动转换引号的行为, quotes: \u0026#39;“”‘’\u0026#39; 则表示将 \u0026#34;123\u0026#34; \u0026#39;123\u0026#39;转换为 “123” ‘123’ enable_rules: disable_rules: plugins: anchors: level: 1 # 开始创建锚点的等级, 默认为2,表示从 H2 开始创建一直到 H6(最后). collisionSuffix: \u0026#39;\u0026#39; # 如果遇到重复的锚点 ID 为其添加数字编号时在这个数字后添加的后缀. permalink: true # 默认为false, 需要更改为true, 来创建一个除标题外带有固定地址的的锚点标签. permalinkClass: \u0026#39;header-anchor\u0026#39; permalinkSide: \u0026#39;left\u0026#39; # 设定为 right 则会在标题后添加固定链接. permalinkSymbol: \u0026#39;\u0026#39; # 更改为空字符串 case: 0 # 转换锚点 ID 中的字母为大写或小写 # \u0026#34;0\u0026#34; 不转换, \u0026#34;1\u0026#34; 为小写, \u0026#34;2\u0026#34; 为大写. “不转换”是为了方便手写Anchor separator: \u0026#39;-\u0026#39; # 用于替换空格的符号. # 默认为 \u0026#34;-\u0026#34; # images: # lazyload: false # prepend_root: false # post_asset: false 当然你也可以直接更改依赖的代码, 但是这样做无法进行版本管理, 所以不推荐:\n进入包目录:\ncd [hexo-site]/node_modules/hexo-renderer-markdown-it 编辑index.js:\nhexo.config.markdown.anchors = Object.assign({ level: 2, collisionSuffix: \u0026#39;\u0026#39;, permalink: true, //更改为true permalinkClass: \u0026#39;header-anchor\u0026#39;, permalinkSide: \u0026#39;left\u0026#39;, permalinkSymbol: \u0026#39;\u0026#39;, //更改为空字符串 case: 0, separator: \u0026#39;-\u0026#39; }, hexo.config.markdown.anchors); 公式自动编号和引用 To enable this feature, you need to set mathjax.tags to ams in NexT config file.\nmath: mathjax: enable: true # Available values: none | ams | all tags: ams 为了使用这项功能，一般来说，你必须把所使用的 LaTeX 公式放在 equation 环境里面，采用旧的方法（也就是说，仅仅把公式的每一边用两个 $ 符号包含起来）是无效的。如何引用公式？你只需要在书写公式的时候给公式一个 \\label{} 标记（tag），然后在正文中，可以使用 \\ref{} 或者 \\eqref{} 命令来引用对应的公式。使用 \\eqref{} 是推荐的方式，因为如果你使用 \\ref{}，公式在文中的引用编号将没有圆括号包围。下面介绍几种常见的公式编号例子.\n对于简单的公式，使用下面的方式给公式一个标记，\n$$\\begin{equation}\\label{eq1} e=mc^2 \\end{equation}$$ 然后，在正文中，你可以轻松引用上述公式，一个简单的例子如下：\n著名的质能方程 $\\eqref{eq1}$ 由爱因斯坦提出 ... Multi-line Equations 对于多行公式，在 equation 环境中，你可以使用 aligned 环境把公式分成多行，\n$$\\begin{equation}\\label{eq2} \\begin{aligned} a \u0026amp;= b + c \\\\ \u0026amp;= d + e + f + g \\\\ \u0026amp;= h + i \\end{aligned} \\end{equation}$$ Multiple Aligned Equations 要对齐多个公式，我们需要使用 align 环境。align 环境中的每个公式都有自己的编号：\n$$\\begin{align} a \u0026amp;= b + c \\label{eq3} \\\\ x \u0026amp;= yz \\label{eq4}\\\\ l \u0026amp;= m - n \\label{eq5} \\end{align}$$ Exclude Equations from Numbering 在 align 环境中，如果你不想给某个或某几个公式编号，那么在这些公式后面使用 \\nonumber 命令即可。例如：\n$$\\begin{align} -4 + 5x \u0026amp;= 2+y \\nonumber \\\\ w+2 \u0026amp;= -1+w \\\\ ab \u0026amp;= cb \\end{align}$$ Use \\tag to Tag Equations 有时，你可能会希望采用更加奇特的方式来标记和引用你的公式，你可以通过使用 \\tag{} 命令来实现，例如：\n$$x+1\\over\\sqrt{1-x^2} \\tag{i}\\label{eq_tag}$$ 如果你想要了解更多信息，请访问 MathJax 关于公式编号的官方文档。同时，你也可以阅读 这篇文档 来获取更多细节信息。\n字体 默认字体(font: false)是Microsoft YaHei, 还挺好看的. 当然也可以自己改字体.\nfont: enable: false 低版本的Next的font: false的中文巨丑, 将font设为true,之后比原来好看了..\n但我也不知道新字体是啥\n代码块 代码高亮(Code Highlight theme): 这个网站可以预览所有高亮效果：传送门\n我使用highlight作为高亮引擎, theme使用a11y-light\n我没有设置代码块行号\nNext Config:\ncodeblock: # Code Highlight theme # All available themes: https://theme-next.js.org/highlight/ theme: # light: default # dark: stackoverflow-dark light: a11y-light dark: a11y-dark prism: light: prism dark: prism-dark # Add copy button on codeblock copy_button: enable: false # Available values: default | flat | mac style: flat Hexo Config:\nhighlight: enable: true line_number: false auto_detect: true tab_replace: \u0026#39;\u0026#39; wrap: true hljs: false prismjs: enable: false preprocess: true line_number: true tab_replace: \u0026#39;\u0026#39; 图像缩放 NexT集成了多种图像显示工具, 包括FancyBox和MediumZoom, 主要功能是图像缩放.\n开启MediumZoom:\n# A JavaScript library for zooming images like Medium. # Warning: Do not enable both `fancybox` and `mediumzoom`. # For more information: https://medium-zoom.francoischalifour.com mediumzoom: true 图像懒加载 npm install hexo-lazyload --save lazyload: true 访客人数\u0026amp;\u0026amp;文章阅读次数 NexT主题已集成了不蒜子的访客人数和文章阅读统计功能:\n# Show Views / Visitors of the website / page with busuanzi. # Get more information on http://ibruce.info/2015/04/04/busuanzi busuanzi_count: enable: true total_visitors: true total_visitors_icon: user fa fa-user total_views: true total_views_icon: eye fa fa-eye post_views: true post_views_icon: eye fa fa-eye 在首页显示文章的阅读次数 点击全文阅读显示阅读次数 在底部可以看见访客人数和文章阅读次数 网页加载加速 使用hexo-filter-optimize来提升网页加载速度:\n下载插件:\nnpm install hexo-filter-optimize 编辑配置文件:\nfilter_optimize: enable: true # remove the surrounding comments in each of the bundled files remove_comments: false css: # minify all css files minify: true # bundle loaded css files into one bundle: true # use a script block to load css elements dynamically delivery: true # make specific css content inline into the html page # - only support the full path # - default is [\u0026#39;css/main.css\u0026#39;] inlines: excludes: js: # minify all js files minify: true # bundle loaded js files into one bundle: true excludes: # set the priority of this plugin, # lower means it will be executed first, default of Hexo is 10 priority: 12 back2top button back2top button非常好看, 默认是添加的:\nback2top: enable: true # Back to top in sidebar. button默认出现在左下角, 如果这里为true,就会出现在sidebar里面(头像, 目录下面),很难察觉 # 所以我设为false sidebar: false # Scroll percent label in b2t button. # 让to-top的小箭头随时显示数值, 我觉得这样破坏阅读体验, 所以为false scrollpercent: false 这里有个插件, 不过已经不需要了. 自带的就很好看.\n版权 选择sidebar, 会在sidebar出现一个小徽章, 不怎么碍眼. 如果选择post, 版权信息会出现在文章底部, 很难看.\n# Creative Commons 4.0 International License. # See: https://creativecommons.org/about/cclicenses/ creative_commons: # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero license: by-nc-sa # Available values: big | small size: small sidebar: true post: false # You can set a language value if you prefer a translated version of CC license, e.g. deed.zh # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org language: 一些不想用的美化 以下美化我都不想用, 只是给出添加方式.\n添加版权信息: 版权信息很丑, 所以我没加\ncreative_commons: license: by-nc-sa sidebar: true post: true 添加评论系统. 我不想加\n夜间模式: 这是永久的, 不能手动切换, 所以我也不想加.\ndarkmode: true Reading progress bar: 五颜六色的,影响观看:\nreading_progress: Reading progress bar enable: false 多主机同步 多主机同步主要的坑在于主题的管理\n多分支 在安装插件后,hexo d会生成网页文件, 并将其部署到GitHub和GitPage. 但是不会把源文件也push到github. 我们需要:\n在Github建两个分支,分别管理生成的网页文件和源文件:\nmaster: 用于存放hexo d 部署的网页文件 hexo: 用于项目源文件, 包括文档源文件 在Github仓库-\u0026gt;Settings-\u0026gt;Branches-\u0026gt;Default branch中将默认分支设为Hexo. 这样每次手动push源文件,都到hexo分支.\n当然也可以每次都手动指定,这样很蠢:\ngit push origin hexo 而我们的hexo d会把生成的网页文件同步到master分支. 这是之前配置hexo d插件时设置的:\ndeploy: type: git repo: github: git@github.com:LYK-love/LYK-love.github.io.git branch: master 多主机同步的问题 我们看到, Hexo添加主题的一般流程是 clone 主题到对应的 themes目录中，然后编辑Hexo的配置文件. 但是, 主题是一个独立的github仓库, 有自己的 .git 文件夹, 也就是说本地的主题项目是嵌套在Hexo项目内的字仓库.\n当push本地仓库时, 是不会push子仓库的, 证据就是, 在github上查看网站项目仓库, 点进\u0026lt;repository\u0026gt;/themes/, 会发现next文件夹有个很奇怪的名字: [next @ XXXXX, 点击它, 会跳转到该主题文件夹对应的github项目. 这说明本地的主题文件夹是一个子项目, 从来没有随着父项目一起被push到github上.\n因此, 当有新主机clone你的hexo仓库时( 比如它要参与多主机同步 ), 它clone下的主题文件夹是空的.\n比如, 我用next主题, 当我买了台新电脑, 想要在它上面同步我开发的hexo. clone下我的网站, 发现项目内themes/next为空. 这样就无法正确生成网站页面了.\n该Bug的表面结果是: hexo生成的index.html也为空( 0kb )\n主题文件夹不会被push, 且每次主题更新时,都会被overwritten, 所以不要更改主题文件夹到任何内容.\n对于主题配置文件. Next官方提供Alternate Theme Config机制来让用户自定义主题配置:\n把主题配置文件复制到Hexo项目目录下, 取名为 _config.[name].yml. Replace [name] with the value of theme option in Hexo config file. For NexT theme, the file name is _config.next.yml by default\n现在主题的配置文件就会读取Hexo项目目录的_config.[name].yml, 而不是主题目录的_config.yml. 由于位于Hexo项目目录下, _config.[name].yml会随着每次的push被push到Hexo项目的仓库. 不用担心子项目问题\n多主机同步时, 新主机只需clone整个项目:\ngit clone https://github.com/LYK-love/LYK-love.github.io 对于CSS之类的文件, 反我是不会改的, 所以无所谓同步. 对于图片, 之前讲了,可以放在项目的/source/images/进行同步( 而不是主题的themes/next/images).\n当然为了保险, 我也另外在项目文件夹内备份了图片文件.\n下文的**@Deprecated 同步步骤**是被废弃的方案, 它使用git modules, 这种方案新建了主题仓库, 然后用git module同步整个主题文件夹, 问题在于这样做就没法进行主题的更新了, 因此废弃\n@New 同步步骤 老主机只需git pull就行了.\n对于本地还没有hexo项目的新主机, 需要:\nclone自己的Hexo项目并初始化:\ngit clone https://github.com/LYK-love/LYK-love.github.io cd LYK-love.github.io npm install 可能会遇到报错:\nERROR Cannot find module \u0026#39;hexo\u0026#39; from \u0026#39;/Users/lyk/Documents/LYK-love.github.io\u0026#39; \u0026lt;Snip\u0026gt; ERROR Try running: \u0026#39;rm -rf node_modules \u0026amp;\u0026amp; npm install --force\u0026#39; 只需按照提示操作即可:\nrm -rf node_modules \u0026amp;\u0026amp; npm install --force 安装主题\n由于下文介绍的Next主题的Alternate Theme Config机制, 主题配置文件已经在Hexo项目文件夹中被我们clone下来了, 也就是说已经同步了, 万事大吉.\n由前文知, hexo-renderer-markdown-it的配置也放在主题配置文件中进行同步了. 但是, images等文件没有同步, 我把images放在Hexo项目文件夹下, 需要手动把它copy到主机文件夹的source/images中\n@Deprecated 同步步骤 注: 该方案已经被废弃\nRef:\n在 hexo 中使用 git submodules 管理主题 在Hexo多主机同步时, 我们当然希望自己的主题配置文件也同步.\nBad Practice: 由于本地的主题项目没办法push, 新主机就只能每次只clone 自己Hexo项目, 然后重新clone官方的主题. 这样做是愚蠢的. 多台机子上开发, 每台的本地都是不同的主题项目, 每次生成网页文件,样式都不一样.\n因此, 我们需要有一个自己的主题项目, 来对主题也进行版本管理. 可以fork官方主题项目, 但我为了方便, 直接创建了自己的主题项目.\nOld Hosts 对于已经加入多主机同步的主机来说, 如果本地更改了主题. 那么每次除了push Hexo项目文件, 还得把再把主题项目文件也push. 否则主题配置的更改是没法同步到Github的.\npush子项目:\ncd ./themes/next git add . \u0026amp;\u0026amp; git commit -m\u0026#34;XXX\u0026#34; git push 要在pull Hexo项目时顺便拉取子项目( 主题项目 ), 这称为update submodule:\n# 把项目的子项目也pull下来 git submodule update --init 当然也可以pull Hexo后手动再pull子项目,这样很蠢:\ncd ./themes/next git pull New Hosts 对于要加入多主机同步的新主机来说, 要把主题文件当作git submodule, 在初始化阶段, 先同步Hexo, 再同步主题.\nclone自己的Hexo项目并初始化:\ngit clone https://github.com/LYK-love/LYK-love.github.io cd LYK-love.github.io npm install 将主题作为submodule添加进来:\ncd blog-hexo git submodule add https://github.com/LYK-love/next themes/next git submodule add \u0026lt;sub-module-registry\u0026gt;: git 会将主题项目( 也就是我的next项目 )作为一个submodule, clone 到 themes/hexo 中.\n同时 hexo 项目中会生成一个 .gitmodules 文件, 这个配置文件中保存了项目 URL 与已经拉取的本地目录之间的映射. .gitmodules 文件内容:\n\u0026gt; cat .gitmodules [submodule \u0026#34;themes/next\u0026#34;] path = themes/next url = git@github.com:LYK-love/next.git update submudule, 第一次update时要加--init选项:\ngit submodule update --init 也可在 clone 父项目时直接使用 git clone --recursive , git 也会pull所有的子项目. 现在新主机已经加入多主机同步, 变成Old Hosts了.\nBugs hexo g 会生成静态文件, 但是，如果你的目录下有失效的软链接， 就不会生成文件。 因此请删除所有的失效软链接\nref： Fixing Hexo Not Generating Files hexo的markdown源代码避免出现跨级标题结构， 这里的跨级指的是不能从一个一级标题直接跟三级标题；二级标题后紧跟的子标题级别必须是三级标题\n文章的Front-matter是YAML格式, 因此冒号后面必须有一个英文空格:\ntitle: XX categories: XX tags: XX 否则报错:\nYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key\n如果表格多了行/列,在显示时会很丑\n极其罕见的Bug, 花了我大半天: Hexo和Next分别更新, 结果Latex不能显示, hexo g巨慢, 页面闪烁, back2top小箭头图表消失等等等等\u0026hellip; 最好他居然神奇地好了. 我猜是package.json冲突了. 不过具体原因我也不知道\u0026hellip; .气死我了.\nHexo Doc 网上没有关于安装指定版本的Hexo的教程. 我的做法是抄一份指定版本的package.json然后npm install\nVersion 查看本地Hexo版本:\nhexo version 查看有哪些落后的版本:\nnpm outdated Install npm install -g hexo-cli Ungrade 安装hexo时需要安装hexo-cli(它包含了hexo在内的一大堆依赖), 而升级hexo只需升级所有插件:\nnpm install -g npm-upgrade npm-upgrade: 升级作为dependency的hexo 查看是否更新成功:\nhexo version Uninstall Uninstall:\nnpm uninstall hexo NeXt Doc NexT 每个月都会发布新版本\nNext Official Doc\nNext Github Repo\n尽量以官方文档为准, Github repo上只有很少的信息.\n注意, Next存在多个Github repo, 请不要被混淆. 例如该repo:\nhttps://github.com/theme-next/hexo-theme-next 这是一个过时的repo, 其next版本只到7.8.0. 而直到本文写作时, next版本已经达到8.15.1了, 因此要注意区分.\nVersion NeXt \u0026lt; 8的版本好像没办法查看\nNext \u0026gt;=8 之后, 每次hexo s/d时在命令行的输出里都有Next版本信息. 此外hexo version也会显示next版本.\nInstallation Next Official Doc: Installation\n由于我不对主题做版本管理, 也就不新开仓库了.\n无论是下载还是更新Next, 都要先更新到最新的Hexo.\nUsing npm npm install hexo-theme-next@latest npm会把主题文件夹下载到/node_modules/hexo-theme-next Using git In hexo directory:\ngit clone https://github.com/next-theme/hexo-theme-next themes/next 注意, 如果在themes/下已经存在了主题文件夹, 则Hexo会忽略node_modules/中可能存在的/主题文件夹. 也就是说要么用git, 要么用npm, 两者不能共存 After Installation 安装成功后就可以使用了, 命令行输入如下:\n❯ hexo s INFO Validating config INFO ================================== ███╗ ██╗███████╗██╗ ██╗████████╗ ████╗ ██║██╔════╝╚██╗██╔╝╚══██╔══╝ ██╔██╗ ██║█████╗ ╚███╔╝ ██║ ██║╚██╗██║██╔══╝ ██╔██╗ ██║ ██║ ╚████║███████╗██╔╝ ██╗ ██║ ╚═╝ ╚═══╝╚══════╝╚═╝ ╚═╝ ╚═╝ ======================================== NexT version 8.15.1 Documentation: https://theme-next.js.org ======================================== INFO Start processing INFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. Upgrade 记得备份old主题文件夹的文件, 把旧主题文件夹rename为next-old. 当然, 由于该文件夹一般什么都不会改,所以不备份也没啥关系\n已经采用了Alternate Theme Config, 因此可以平滑地升级:\ngit pull Markdown 页面内跳转 Anchor Auto 只需要使用hexo-renderer-markdown-it, 并修改其配置文件, 就可以使文章Header自带Anchor\nManual 例子:\nMarkdown的一个标题:\n// in markdown: # Ha ha dadads 会被Hexo渲染成:\n//in html \u0026lt;id = \u0026#34;ha-ha\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;dadads\u0026lt;/h1\u0026gt; 空格会被转换为连字符, 大写会被转换为小写. 由于我在hexo-renderer-markdown-it中的配置, 空格会被转换为-, 而大小写是不转换的 如果有重名的标题(即使处于不同的标题层次), 就会在html的标签的id属性中予以区分:\n// in markdown: # haha dadads # Heihei ## Haha //重名了 asa //in html \u0026lt;id = \u0026#34;haha-1\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;dadads\u0026lt;/h1\u0026gt; \u0026lt;id = \u0026#34;haha-2\u0026#34;\u0026gt; //用数字后缀区分了 \u0026lt;h1\u0026gt;asa\u0026lt;/h1\u0026gt; 因此, 只需要在markdown中写:\n[显示的内容](#标题) 生成的Html是:\n\u0026lt;a href=\u0026#34;标题\u0026#34;\u0026gt;显示的内容\u0026lt;/a\u0026gt; 这就引用了对应的标题:\n# 标题 可以看到, 这是基于Html的标签id匹配的, 而Markdown标题生成的Html标签的id和标题级别没有关系, 只和标题名字有关系. 所以\n[显示的内容](#KKK) 可以引用到:\n# Haha ## KKK 中的二级标题KKK\n由于空格会被转换为-, 因此如果标题为:\n# Traditional Dead Lift 则应该这样引用:\n[显示的内容](#Traditional-Dead-Lift) ","permalink":"https://lyk-love.cn/Hugo-Blog/posts/hexo/","posts_num":12,"tags":null,"title":"Hexo"},{"categories":["Algorithm"],"contents":"Outline:\nHow to Compare Two Algorithms Brute Force by Iteration Brute Force by Recursion How to Compare Two Algorithms (c) $(c)$\nAlgorithm analysis, with simplification Measure the cost by the number of critical operations Large input size only Essential part only Only the leading term in$ f(n)$ is considered Constant coefficients are ignored Capturing the essential part in the cost in a mathematical way Asymptotic growth rate of $f(n)$ Relative Growth Rate $O(g):$​​ functions $A_1, A_2,\u0026hellip;$that grows no faster than $g$​\n$O(g(n))={f(n): 存在常数c\u0026gt;0和n_0\u0026gt;0,满足0\\leq f(n) \\leq cg(n)对所有n \\geq n_0均成立}$​ $f(n)=O(g(n)) \\quad iff \\quad \\lim\\limits_{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=c\u0026lt;\\infty$ $o(g)$: 不快于$g$且与$g$有层次上的差距\n$o(g(n))={f(n): 对任意常数c\u0026gt;0, 均存在常数n_0\u0026gt;0,满足0\\leq f(n) \u0026lt; cg(n)对所有n \\geq n_0均成立}$​​​ $f(n)=o(g(n)) \\quad iff \\quad \\lim\\limits_{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=0$​ $\\Omega(g)$: functions that grow at least as fast as $g$​\n$\\Omega(g(n))={f(n): 存在常数c\u0026gt;0和n_0\u0026gt;0,满足0 \\leq cg(n)\\leq f(n) 对所有n \\geq n_0均成立}$ $f(n)=\\Omega(g(n)) \\quad iff \\quad \\lim\\limits_{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=c\u0026gt;0(c也可以为\\infty)$​ $\\omega$: 不慢于$g$且与$g$有层次上的差距\n$\\omega(g(n))={f(n): 对任意常数c\u0026gt;0,均存在常数n_0\u0026gt;0,满足0 \\leq cg(n) \u0026lt; f(n) 对所有n \\geq n_0均成立}$​ $f(n)=\\omega(g(n)) \\quad iff \\quad \\lim\\limits_{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=\\infty$​​ $\\Theta(g):$​​ \u0026hellip; the same rate as $g$​​. (处于同一水平) ( $O$和$\\Omega$的交集 )\n$\\Theta(g(n))={f(n): 存在常数c_1\u0026gt;0,c_2\u0026gt;0和n_0\u0026gt;0,满足0 \\leq c_1g(n)\\leq f(n) \\leq c_2g(n) 对所有n \\geq n_0均成立}$ $f(n)=\\Theta(g(n)) \\quad iff \\quad \\lim\\limits_{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=c\u0026gt;0(0\u0026lt;c\u0026lt;\\infty)$​​ $\\theta$: 不存在， $o$​和$\\omega$​的交集是空集\nBrute Force by Iteration Max-sum Subsequence\n蛮力是$O(n^3)$, 改进一下是$O（n^2）$​，用分治改进是$O（nlogn）$\nA linear Algorithm: O(n)\nThisSum = MaxSum = 0; for( j = 0 ; j \u0026lt; N ; j++ ) { ThisSum += A[j]; if( ThisSum \u0026gt; MaxSum ) MaxSum = ThisSum; else if( ThisSum \u0026lt; 0 ) ThisSum = 0; } Return MaxSum Brute Force by Recursion 蛮力策略大智若愚，可以以此为跳板进行改进\nJob Scheduling\nBrute force recursion Select job \u0026lsquo;a\u0026rsquo; Case 1: the result does not contain \u0026lsquo;a\u0026rsquo; Recursion on $J \\setminus {a}$​​ Case 2: the result contains \u0026lsquo;a\u0026rsquo; Recursion on $J \\setminus {a} \\setminus {$ ​ tasks overlapping with $ a}$​ Further improvements Dynamic programming(L16) Greedy algorithms( L14 ) Matrix Chain Multiplication\nSolutions Brute force recursion(L16) BF1 BF2 Dynamic programming(L16) Based on brute force recursion 2 ","permalink":"https://lyk-love.cn/Hugo-Blog/posts/l2-asymptotics/","posts_num":12,"tags":["Algorithm design and analysis"],"title":"L2 Asymptotics3000"},{"categories":null,"contents":"Outline:\nIntro： 多处理器编程的困难 用状态机理解并发算法 并发控制：互斥、同步 概念： 互斥 并发与状态机 Threading API Lock Concurrent Data Structure based on Lock Conditional Variable 信号量 常见并发问题 基于事件的并发 Ref：\nOperating Systems Three Easy pieces JYY OS Intro Concurrent：exsiting, happening, or done at the same time. 程序的不同部分可以按不同顺序执行，且最终得到正确的结果\n//t0.c #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;assert.h\u0026gt; #include\u0026lt;pthread.h\u0026gt;// pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a // 在编译中要加 -lpthread参数 void *mythread( void *arg ) { printf(\u0026#34;%s\\n\u0026#34;, arg); return NULL; } int main( int argc, char* argv[]) { pthread_t p1,p2; int rc; printf( \u0026#34;main:begin\\n\u0026#34; ); char* ch1 = \u0026#34;A\u0026#34;; char* ch2 = \u0026#34;B\u0026#34;; rc = pthread_create( \u0026amp;p1, NULL, mythread, ch1 ); assert(rc==0); //C语言编译器允许隐含性的将一个通用指针转换为任意类型的指针，包括const *而C＋＋不允许将const 转换为非const*，所以不能直接传入\u0026#34;A\u0026#34; rc = pthread_create( \u0026amp;p2, NULL, mythread, ch2 ); assert(rc==0); rc= pthread_join( p1,NULL ); rc= pthread_join( p2,NULL ); printf(\u0026#34;main:end\\n\u0026#34;); } 该程序打印结果为：\nmain:begin A B main:end 或者\nmain:begin B A main:end 两次运行结果不一样\n多任务OS的并发 （假设系统只有一个CPU）\nOS可以同时加载多个进程\n每个进程都是独立的进程，互不干扰\n即使是root权限的进程，也不能直接访问操作系统内核的内存 每隔一段时间，就切换到另一个进程\n并发性的来源： 进程会调用OS的API write（fd,buf,11 TiB）（TiB宏） write的实现是OS的一部分 x86-64应用程序执行syscall后就进入OS执行 类似中断处理程序 此时OS允许write的同时，让另一个进程执行 如：另一个进程执行了read(fd,buf,512 MiB)读取同一文件 OS代码并发了： OS API实现需要考虑并发 虽然进程在地址空间中是独立的，但是OS中的对象是被进程共享的 并发与并行的区别 并发： 多个执行流可以不按照一个特定的顺序执行 并行：允许多个执行流真正地同时执行 需要多个处理器 处理器数量 共享内存？ 典型的并发OS 并发？并行？ 单 共享内存 OS内核/多线程程序 并发不并行 多 共享内存 OS内核/多线程程序/GPU Kernel 并发、并行 多 不共享内存 分布式系统（消息通信） 并发、并行 线程 线程： A single process can contain multiple threads, all of which are executing the same program. These threads share the same global memory (data and heap segments), but each thread has its own stack (automatic variables).\n多个执行流并发/并行执行，且共享内存\n两个执行流共享代码和所有全局变量（数据区、堆区） i.e. C++中，数据区就是全局/静态区 线程间指令的执行顺序是不确定（non-deterministic）的 共享：共享代码区(当前进程的代码)、数据区和堆，但不共享寄存器和栈 //t1.c //共享全局变量的后果 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;pthread.h\u0026gt; #include\u0026#34;mythreads.h\u0026#34; static volatile int counter = 0; void * mythread( void*arg ) { printf( \u0026#34;%s: begin\\n\u0026#34;, (char*)arg ); int i; for( int i = 0 ; i \u0026lt; 1e7; i++ ) counter++; printf(\u0026#34;%s: done\\n\u0026#34;, (char*)arg); return NULL; } int main( int argc, char* argv[]) { pthread_t p1,p2; int rc; printf( \u0026#34;main:begin ( counter = %d )\\n\u0026#34;, counter ); char* ch1 = \u0026#34;A\u0026#34;; char* ch2 = \u0026#34;B\u0026#34;; Pthread_create( \u0026amp;p1, NULL, mythread, ch1 ); //C语言编译器允许隐含性的将一个通用指针转换为任意类型的指针，包括const *而C＋＋不允许将const 转换为非const*，所以不能直接传入\u0026#34;A\u0026#34; Pthread_create( \u0026amp;p2, NULL, mythread, ch2 ); Pthread_join( p1,NULL ); Pthread_join( p2,NULL ); printf(\u0026#34;main:done with both ( counter = %d )\\n\u0026#34;, counter); } //mythreads.h //把API封装起来，易于使用 #include\u0026lt;pthread.h\u0026gt; // #include\u0026lt;assert.h\u0026gt; void Pthread_create (pthread_t *__restrict __newthread, const void* __attr, void *(*__start_routine) (void *), void *__restrict __arg) { pthread_create( __newthread, __attr, __start_routine, __arg ); } void Pthread_join(pthread_t __th, void **__thread_return) { pthread_join( __th, __thread_return ); } void *Malloc(unsigned size) { return malloc(size); } 输出为：\nmain:begin ( counter = 0 ) A: begin B: begin A: done B: done main:done with both ( counter = 12275324 ) 可以看到结果不是200000, 而是12275324\n再运行一次：\nmain:begin ( counter = 0 ) A: begin B: begin B: done A: done main:done with both ( counter = 10467369 ) 两次运行的结果都不一样！\n多处理器编程的困难 原子性： 即使是i++，也会被分成几个指令 顺序性：代码的编译器优化 可见性： CPU可以不按顺序执行指令。没有前后依赖就会被优化（并行执行） 并发术语 临界区( critical section )： 访问共享资源的一段代码 竞态条件( race condition )： 多个执行线程大致同时进入进阶区时，都试图更新共享资源的情况 不确定性( indeterminate )： 程序含有竞态条件，其输出不确定 同步原语( synchronization primitive ):硬件提供指令，在其上构建同步原语,实现原子性 互斥原语( mutual exclusion )： 线程应该使用互斥原语，以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出 概念：互斥 互斥（mutual exclusion）\ntypedef struct{ ... }lock_tl void lock(lock_t *lk);//试图获得锁的独占访问，成功获得后返回 void unlock(lock_t *lk);//释放锁的独占空间 我们假设CPU有三种指令：\nload： mem -\u0026gt; reg store: reg -\u0026gt; mem 本地计算： 线程的寄存器做一些计算，结果存入寄存器 共享内存上互斥的困难 load和store的缺陷（一个只能看，一个只能写）\n现代处理器load/store可能在执行时被乱序\n并发与状态机 程序 = 有限状态机 = 有向图 图论是理解程序的重要工具\n不确定(non-deterministic)的指令可能有多个状态\n获取处理器的”时间戳“用于精确定时\nrdtsc/rdtscp 机器提供的”真“随机数\nrdrand syscall\n一般用于唯一不确定性的来源 read 状态机模型：应用 在硬件上的应用： 高性能处理器实现 超标量处理器 同一时间执行多条指令 Time - Travel Debugging 程序执行随时间渐进：$s_0 \\rarr s_1 \\rarr \\dots$​\n记录所有$s_i$的开销太大（$s_i$​由内存和寄存器组成）\n记录初始状态，和每条指令前后状态的diff\nsi/rsi\nRecord \u0026amp; Replay 确定的程序不需要任何记录，只需要再执行一次\n只需记录non-deterministic指令的效果（side-effect），就可实现重放 线程间通信ITC (1)通信线程位于同一个进程中，共享相同的地址空间\n(2)通信线程位于不同的进程中，拥有不同的地址空间\n相同进程 对于情况(1)，线程间的通信可以直接通过访问共享的地址空间实现信息交换\n不同进程 对于情况(2), 采用进程间通信IPC\n• IPC机制主要包括:信号(Signal)、管道(Pipe)、信号量、共享内存(Shared Memory)、消息队列(Message Queue)、套接字(Socket)\n• 与线程间通信机制不同，进程间通信机制需要打破进程间地址空间的隔离\n某些OS发行版(.其实就是欧拉 )增加的IPC机制：共享内存， 消息通信\n共享内存是一种在进程间高效地传递大量信息的通信方式。但在共享内存机制下，信息的发送方不关心信息由谁接收，而信息的接收方也不关心信息是由谁发送的，这存在安全隐患。 消息传递允许进程不必通过共享内存区来实现通信，而是通过交换消息的方式来实现通信。消息 传递关注信息的发送者不接收者，通过使用内核拷贝传递的信息，完成进程间的信息传递 Threading API man -k pthread\n//p212, 线程API #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;pthread.h\u0026gt; #include\u0026#34;mythreads.h\u0026#34; #include\u0026lt;stdlib.h\u0026gt; typedef struct myarg_t{ int a; int b; }myarg_t; typedef struct myret_t{ int x; int y; }myret_t; void * mythread( void*arg ) { myarg_t *m = (myarg_t *)arg; printf( \u0026#34;args: %d %d\\n\u0026#34;, m -\u0026gt; a, m -\u0026gt; b ); myret_t *r = Malloc(sizeof( myret_t )); r -\u0026gt; x = 1; r -\u0026gt; y = 2; return (void*) r; } int main( int argc, char* argv[]) { pthread_t p; int rc; myret_t *m; //将返回值打包 myarg_t args;//将参数打包 args.a = 10; args.b = 20; Pthread_create( \u0026amp;p, NULL, mythread, \u0026amp;args ); Pthread_join( p, ( void **) \u0026amp;m );//将线程返回值赋给m printf(\u0026#34;returned: %d %d\\n\u0026#34;, m -\u0026gt; x, m -\u0026gt; y ); } 输出为：\nargs: 10 20 returned: 1 2 线程创建 \u0026lt;pthread.h\u0026gt;\n/* Create a new thread, starting with execution of START-ROUTINE getting passed ARG. Creation attributed come from ATTR. The new handle is stored in *NEWTHREAD. */ extern int pthread_create (pthread_t *__restrict __newthread, //线程的指针 const pthread_attr_t *__restrict __attr, //线程具有的属性，包括栈大小，优先级等。 一般传入NULL void *(*__start_routine) (void *),//线程要运行的函数的指针，接受void*参数，返回 void* //可以自由更改参数/返回类型 void *__restrict __arg) __THROWNL __nonnull ((1, 3));//函数的参数，可传入结构体，以实现传入多个参数 线程完成 /* Make calling thread wait for termination of the thread TH. The exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN is not NULL. This function is a cancellation point and therefore not marked with __THROW. */ extern int pthread_join (pthread_t __th, void **__thread_return); /* 第一个参数是线程的指针 第二个参数是线程运行的函数的返回值的指针 */ 锁 //上锁和解锁 extern int pthread_mutex_lock (pthread_mutex_t *__mutex) extern int pthread_mutex_unlock (pthread_mutex_t *__mutex) //锁必须初始化，两种方式 pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_init(*lock, NULL) //锁使用完后必须销毁 extern int pthread_mutex_destroy (pthread_mutex_t *__mutex) //mythread.h #include\u0026lt;pthread.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;assert.h\u0026gt; typedef pthread_cond_t cond_t; typedef pthread_mutex_t mutex_t; void Pthread_create (pthread_t *__restrict __newthread, const void* __attr, void *(*__start_routine) (void *), void *__restrict __arg) { int rc = pthread_create( __newthread, __attr, __start_routine, __arg ); assert( rc == 0 ); } void Pthread_join(pthread_t __th, void **__thread_return) { int rc = pthread_join( __th, __thread_return ); assert( rc == 0 ); } void *Malloc(unsigned size) { return malloc(size); } void Pthread_mutex_lock( pthread_mutex_t *mutex ) { int rc = pthread_mutex_lock(mutex); assert( rc == 0 ); } void Pthread_mutex_unlock( pthread_mutex_t *mutex ) { int rc = pthread_mutex_unlock(mutex); assert( rc == 0 ); } void Pthread_mutex_init( pthread_mutex_t *__mutex, const void*__mutexattr ) { int rc = pthread_mutex_init(__mutex, NULL); assert( rc == 0 ); } void Pthread_mutex_destroy( pthread_mutex_t *__mutex ) { int rc = pthread_mutex_destroy(__mutex); assert( rc == 0 ); } void Pthread_cond_init( pthread_cond_t *__restrict __cond, const void*__restrict __cond_attr ) { int rc = pthread_cond_init( __cond, __cond_attr); assert( rc == 0 ); } void cond_destroy( pthread_cond_t *__restrict __cond ) { int rc = pthread_cond_destroy(__cond); assert( rc == 0 ); } void Pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) { int rc = pthread_cond_wait(__cond, __mutex); assert(rc ==0 ); } void Pthread_cond_signal(pthread_cond_t *__cond) { int rc = pthread_cond_signal(__cond); assert( rc==0 ); } 使用锁：\npthread_mutex_t lock; Pthread_mutex_init( \u0026amp;lock ,NULL );//初始化锁 Pthread_mutex_lock( \u0026amp;lock );//上锁， 如果锁已经被其他线程持有，那么该调用不会返回，直到获得该锁（意味着持有该锁的线程已经将锁释放） x = x +1; Pthread_mutex_unlock( \u0026amp;lock ); 条件变量 /* Wait for condition variable COND to be signaled or broadcast. MUTEX is assumed to be locked before. This function is a cancellation point and therefore not marked with __THROW. */ extern int pthread_cond_wait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex); /* Wake up one thread waiting for condition variable COND. */ extern int pthread_cond_signal (pthread_cond_t *__cond); //条件变量也必须初始化，与锁类似，两种方式： pthread_cond_t cond = PTHREAD_COND_INITIALIZER; pthread_cond_init( __cond, __cond_attr); //销毁也类似 /* Destroy condition variable COND. */ extern int pthread_cond_destroy (pthread_cond_t *__cond); //mythreads.h void Pthread_cond_init( pthread_cond_t *__restrict __cond, const void*__restrict __cond_attr ) { int rc = pthread_cond_init( __cond, __cond_attr); assert( rc == 0 ); } void cond_destroy( pthread_cond_t *__restrict __cond ) { int rc = pthread_cond_destroy(__cond); assert( rc == 0 ); } Lock 锁的状态：\navailable acquired 方法：\nlock(): 尝试获取锁，如果锁是available，则获取锁，进入临界区 unlock(): 使锁available 锁提供了最小程度的调度控制\n线程由OS调度， 锁让程序员获得了一些控制权 通常用不同的锁保护不同的数据（ 细粒度的方案 ）\n评价锁 有效性： 提供互斥 公平性fairness: 当锁可用时，是否每一个竞争线程有公平的机会抢到锁 是否有竞争锁的线程会饿死starve? 性能 performance 控制中断 最早提供的互斥解决方案之一，就是在临界区关闭中断：\nvoid lock(){ DisableInterrupts(); } void unlock(){ EnableInterrupts(); } 假设在单CPU系统上，这段代码在临界区关闭中断，从而原子地执行，结束后又重新打开中断\n缺点：\n需要允许所有线程执行特权操作（开关中断） 即，需要信任机制不被滥用 不支持多处理器 中断的开关只是对CPU而言，如果一个多个线程运行在不同CPU上，其中一个CPU关闭中断，其他CPU依然响应中断，在其上的线程依然能进入临界区 关中断导致中断丢失，可能导致严重的系统问题 比如磁盘完成了读取请求，但CPU错失了该消息 因此，用关中断来实现互斥原语的情况很有限\n有些情况下OS自身会采用关中断的方式来保证访问数据的原子性，此时该用法是可行的，因为OS内部不存在信任问题 很多人热衷于研究不依赖硬件实现的锁机制，事实证明，只需很少的硬件支持，实现锁就会容易很多\ntest-and-set test-and-set instruction, 也称为atomic exchange, 由硬件支持\n先实现一个不依赖它的锁：\n//想法是： 用一个flag来表示锁是否被占用 typedef struct lock_t( int flag; ) lock_t; void init( lock_t *mutex ) { mutex -\u0026gt; flag = 0; // 0 -\u0026gt; lock is available } void lock( lock_t *mutex ) { while( mutex -\u0026gt; flag == 1 ) ; // spin-wait( do nothing ) mutex -\u0026gt; flag = 1; } void unlock( lock_t *mutex ) { mutex -\u0026gt; flag = 0; } 这段代码有两个问题：\n正确性：\nThread` Thread2 ( 初始时，flag == 0 ) call lock() while( flag == 1 ) interrupt: switch to Thread2 call lock() while( flag == 1 ) flag = 1; interrupt: switch to Thread 1 flag = 1( too ! ) 性能问题：\n这个锁是自旋的，一个线程自旋等待另一个线程释放锁，浪费时间 对于单CPU，因为同一时间只有一个线程，且自旋的线程永远不会放弃CPU,本线程自旋时，持有锁的线程根本无法运行，也不可能释放锁 需要抢占式的调度器（ preemptive scheduler , 即不断通过时钟中断一个线程，运行其他线程 ) 用test-and-set实现锁 在x86上称为 xchg指令， ```c int TestAndSet( int *old_ptr, int new ) { int old = *old_ptr; *old_ptr = new; return old; }// 返回old_ptr指向的旧值，将old_ptr指向新值 ``` 硬件保证，上述操作是原子的 可以理解为：一个厕所门上挂着钥匙(0)，两个用户都有一个名牌(1)，用户每次进出厕所，需要拿手上的东西和门上的东西交换，用户需要拿到钥匙才能进厕所。\n用户一拿名牌和钥匙交换，拿着钥匙进了厕所\n用户二拿名牌交换，此时门上是名牌，用户二没有拿到钥匙，无法进厕所\n他会一直交换：\nwhile( TestAndSet( \u0026amp;lock -\u0026gt; flag, 1 ) == 1 ) ; //spin 用户一从厕所出来，拿名牌和手上的钥匙交换，此时门上又有钥匙了\n缺点：\n如上述 评价自旋锁：\n有效性：OK 公平性：不提供任何公平性保证( 对test-and-set而言 ) 性能： 单核下很差，多核下还不错 compare-and-exchange 某些系统提供了另一个硬件原语: compare-and-exchange( on x86 )\n//返回ptr指向的旧值，将ptr指向新值（如果旧值与期望值相等的话） int CompareAndExchange( int *ptr, int expected, int new ) { int actual = *ptr; if( actual == expected ) *ptr = new; return actual; } 该指令比test-and-set更强大\nfetch-and-add int FetchAndAdd( int *ptr ) { int old = *ptr; *ptr = old + 1; return old; } typedef struct lock_t { int ticket; int turn; } lock_t; void lock_init( lock_t *lock ) { lock -\u0026gt; ticket = 0; lock -\u0026gt; turn = 0; } void lock(lock_t *lock) { int myturn = FetchAndAdd( \u0026amp;lock-\u0026gt;ticket ); while( lock-\u0026gt; turn != myturn ) ; //spin } void unlock( lock_t *lock ) { FetchAndAdd( \u0026amp;lock-\u0026gt; turn ); } 解释：ticket是一个全局的号码，turn是全局的轮次。 每个用户从ticket得到自己的turn， 每交易一次，ticket++. 只有到达自己的turn的用户才能进入临界区，每当一个用户从临界区出来， turn++\nmyturn \u0026lt; turn的用户只能自旋 本方法能保证所有线程都能抢到锁，只要一个线程获得了ticket，就能被调度\ntest-and-set无法保证 自旋过多的解决方案 我们已经实现了有效、公平（ 借助ticket）的锁，但自旋会导致性能降低 自旋会重复检查一个不会改变的值，浪费CPU时间 方案一 yield 在要自旋的时候，放弃CPU void lock() { while( TestAndSet(\u0026amp;flag, 1 ) == 1 ) yield(); //give up the CPU } 假定OS提供原语yield()，可以让线程从running变为ready 本质上，就是deschedule 假设100个线程竞争1个锁，该方案会yield99次，比自旋99次好，但仍不够完美 方案二 使用队列： 休眠代替自旋 1 typedef struct lock_t { 2 int flag; 3 int guard; 4 queue_t *q; 5 } lock_t; 6 7 void lock_init(lock_t *m) { 8 m-\u0026gt;flag = 0; 9 m-\u0026gt;guard = 0; 10 queue_init(m-\u0026gt;q); 11 } 12 13 void lock(lock_t *m) { 14 while (TestAndSet(\u0026amp;m-\u0026gt;guard, 1) == 1) 15 ; //acquire guard lock by spinning 16 if (m-\u0026gt;flag == 0) { 17 m-\u0026gt;flag = 1; // lock is acquired 18 m-\u0026gt;guard = 0; 19 } else { 20 queue_add(m-\u0026gt;q, gettid()); 21 m-\u0026gt;guard = 0; 22 park(); 23 } 24 } 25 26 void unlock(lock_t *m) { 27 while (TestAndSet(\u0026amp;m-\u0026gt;guard, 1) == 1) 28 ; //acquire guard lock by spinning 29 if (queue_empty(m-\u0026gt;q)) 30 m-\u0026gt;flag = 0; // let go of lock; no one wants it 31 else 32 unpark(queue_remove(m-\u0026gt;q)); // hold lock (for next thread!) 33 m-\u0026gt;guard = 0; 34 } 看不懂QAQ,为啥unpark的时候不把flag设为0啊，这样所有其他进程都无法获得锁\nConcurrent Data Structure Based on Lock 通过锁使得数据thread safe 可扩展性： 理想状态下的多线程的每个线程就和单线程一样快，二者的比值就是并发方法的扩展性 并发计数器 1 typedef struct counter_t { 2 int value; 3 pthread_mutex_t lock; 4 } counter_t; 5 6 void init(counter_t *c) { 7 c-\u0026gt;value = 0; 8 Pthread_mutex_init(\u0026amp;c-\u0026gt;lock, NULL); 9 } 10 11 void increment(counter_t *c) { 12 Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); 13 c-\u0026gt;value++; 14 Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); 15 } 16 17 void decrement(counter_t *c) { 18 Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); 19 c-\u0026gt;value--; 20 Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); 21 } 22 23 int get(counter_t *c) { 24 Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); 25 int rc = c-\u0026gt;value; 26 Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); 27 return rc; 28 } 性能一般 扩展并发计数器 懒惰计数器sloopy counter: 例如，在4CPU机器上，有四个局部计数器和一个全局计数器，每个计数器有一把锁。\n不同CPU上的计数器不会竞争 为了保持全局计数器更新，如果局部值大于阈值S，局部值就要转移到全局值（此时要获取全局锁） 阈值越大，可扩展性越好，但计时器精度更低 1 typedef struct counter_t { 2 int global; // global count 3 pthread_mutex_t glock; // global lock 4 int local[NUMCPUS]; // local count (per cpu) 5 pthread_mutex_t llock[NUMCPUS]; // ... and locks 6 int threshold; // update frequency 7 } counter_t; 8 9 // init: record threshold, init locks, init values 10 // of all local counts and global count 11 void init(counter_t *c, int threshold) { 12 c-\u0026gt;threshold = threshold; 13 14 c-\u0026gt;global = 0; 15 pthread_mutex_init(\u0026amp;c-\u0026gt;glock, NULL); 16 17 int i; 18 for (i = 0; i \u0026lt; NUMCPUS; i++) { 19 c-\u0026gt;local[i] = 0; 20 pthread_mutex_init(\u0026amp;c-\u0026gt;llock[i], NULL); 21 } 22 } 23 24 // update: usually, just grab local lock and update local amount 25 // once local count has risen by \u0026#39;threshold\u0026#39;, grab global 26 // lock and transfer local values to it 27 void update(counter_t *c, int threadID, int amt) { 28 pthread_mutex_lock(\u0026amp;c-\u0026gt;llock[threadID]); 29 c-\u0026gt;local[threadID] += amt; // assumes amt \u0026gt; 0 30 if (c-\u0026gt;local[threadID] \u0026gt;= c-\u0026gt;threshold) { // 局部值大于阈值，transfer to global 31 pthread_mutex_lock(\u0026amp;c-\u0026gt;glock); 32 c-\u0026gt;global += c-\u0026gt;local[threadID]; 33 pthread_mutex_unlock(\u0026amp;c-\u0026gt;glock); 34 c-\u0026gt;local[threadID] = 0;//本地值清0, 注意到不会与其他cpu上的线程竞争，因此是安全的 35 } 36 pthread_mutex_unlock(\u0026amp;c-\u0026gt;llock[threadID]); 37 } 38 39 // get: just return global amount (which may not be perfect) 40 int get(counter_t *c) { 41 pthread_mutex_lock(\u0026amp;c-\u0026gt;glock); 42 int val = c-\u0026gt;global; 43 pthread_mutex_unlock(\u0026amp;c-\u0026gt;glock); 44 return val; // only approximate! 45 } 并发链表 1 // basic node structure，单链表 2 typedef struct node_t { 3 int key; 4 struct node_t *next; 5 } node_t; 6 7 // basic list structure (one used per list) 8 typedef struct list_t { 9 node_t *head; 10 pthread_mutex_t lock; 11 } list_t; 12 13 void List_Init(list_t *L) { 14 L-\u0026gt;head = NULL; 15 pthread_mutex_init(\u0026amp;L-\u0026gt;lock, NULL); 16 } 17 18 int List_Insert(list_t *L, int key) { 19 pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); 20 node_t *new = malloc(sizeof(node_t)); 21 if (new == NULL) { 22 perror(\u0026#34;malloc\u0026#34;); 23 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); //malloc失败，记得释放锁！ 24 return -1; // fail 25 } 26 new-\u0026gt;key = key; 27 new-\u0026gt;next = L-\u0026gt;head; 28 L-\u0026gt;head = new; 29 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); 30 return 0; // success 31 } 32 33 int List_Lookup(list_t *L, int key) { 34 pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); 35 node_t *curr = L-\u0026gt;head; 36 while (curr) { 37 if (curr-\u0026gt;key == key) { 38 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); //在意外退出时unlock 39 return 0; // success 40 } 41 curr = curr-\u0026gt;next; 42 } 43 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); 44 return -1; // failure 45 } 在开头lock,结尾unlock, 注意到malloc失败后也要记得unlock 这种在代码中多次unlock的写法很丑陋！ 应该修改 要么出错的地方不要放在临界区 要么出错时break到主循环，在主循环内统一unlock 这是粗粒度的写法，可以更细粒度地优化： 18 int List_Insert(list_t *L, int key) { 19 //local的数据，不需要锁保护 20 node_t *new = malloc(sizeof(node_t)); 21 if (new == NULL) { 22 perror(\u0026#34;malloc\u0026#34;); 23 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); //出错时不在临界区，无需unlock 24 return -1; 25 } 26 new-\u0026gt;key = key; 27 //just lock critical section !!!!! 28 pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); 29 new-\u0026gt;next = L-\u0026gt;head; 30 L-\u0026gt;head = new; 31 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); 32 return 0; 33 } 33 int List_Lookup(list_t *L, int key) { int rv = -1;// success / failure 34 pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); 35 node_t *curr = L-\u0026gt;head; 36 while (curr) { 37 if (curr-\u0026gt;key == key) { 38 rv=0; 39 break; // 跳出主循环，在主循环内统一unlock ！！！ 40 } 41 curr = curr-\u0026gt;next; 42 } 43 pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); 44 return rv; // now both success and failure 45 } 扩展链表 过手锁hand-overohand locking: 每个节点都有一个锁，替代之前整个链表一个锁，遍历链表时，首先抢占下一个节点的锁，然后释放当前节点的锁 开销巨大，未必比单锁快 注意控制流的变化导致函数返回和退出，这种情况下要记得释放锁 并发队列 粗粒度的锁很简单，接下来使用细粒度的锁\n对队列头和尾各设置一个锁 因为出队只访问head锁， 入队只访问tail锁， 两把锁使得出队和入对可以并发执行 1 typedef struct node_t { 2 int value; 3 struct node_t *next; 4 } node_t; 5 6 typedef struct queue_t { 7 node_t *head; 8 node_t *tail; 9 pthread_mutex_t headLock; 10 pthread_mutex_t tailLock; 11 } queue_t; 12 13 void Queue_Init(queue_t *q) { 14 node_t *tmp = malloc(sizeof(node_t)); 15 tmp-\u0026gt;next = NULL; 16 q-\u0026gt;head = q-\u0026gt;tail = tmp; 17 pthread_mutex_init(\u0026amp;q-\u0026gt;headLock, NULL); 18 pthread_mutex_init(\u0026amp;q-\u0026gt;tailLock, NULL); 19 } 20 21 void Queue_Enqueue(queue_t *q, int value) { 22 node_t *tmp = malloc(sizeof(node_t)); 23 assert(tmp != NULL); 24 tmp-\u0026gt;value = value; 25 tmp-\u0026gt;next = NULL; 26 27 pthread_mutex_lock(\u0026amp;q-\u0026gt;tailLock);//入队只访问`tail`锁 28 q-\u0026gt;tail-\u0026gt;next = tmp; 29 q-\u0026gt;tail = tmp; 30 pthread_mutex_unlock(\u0026amp;q-\u0026gt;tailLock); 31 } 32 33 int Queue_Dequeue(queue_t *q, int *value) { 34 pthread_mutex_lock(\u0026amp;q-\u0026gt;headLock);//出队只访问`head`锁 35 node_t *tmp = q-\u0026gt;head; 36 node_t *newHead = tmp-\u0026gt;next; 37 if (newHead == NULL) { 38 pthread_mutex_unlock(\u0026amp;q-\u0026gt;headLock); 39 return -1; // queue was empty，这种写法（在子控制流unlock）很丑陋，应该像之前《重写并发链表》的 List_Lookup() 一样改造 40 } 41 *value = newHead-\u0026gt;value; 42 q-\u0026gt;head = newHead; 43 pthread_mutex_unlock(\u0026amp;q-\u0026gt;headLock); 44 free(tmp); 45 return 0; 46 } 并发散列表 每个元素都是一个并发链表，也称为“散列桶” 每个散列桶都有一个锁 1 #define BUCKETS (101) 2 3 typedef struct hash_t { 4 list_t lists[BUCKETS]; 5 } hash_t; 6 7 void Hash_Init(hash_t *H) { 8 int i; 9 for (i = 0; i \u0026lt; BUCKETS; i++) { 10 List_Init(\u0026amp;H-\u0026gt;lists[i]); 11 } 12 } 13 14 int Hash_Insert(hash_t *H, int key) { 15 int bucket = key % BUCKETS; 16 return List_Insert(\u0026amp;H-\u0026gt;lists[bucket], key); 17 } 18 19 int Hash_Lookup(hash_t *H, int key) { 20 int bucket = key % BUCKETS; 21 return List_Lookup(\u0026amp;H-\u0026gt;lists[bucket], key); 22 } Conclusion Knuth定律： 避免不成熟的优化 先最简单的方案，也就是加大锁（ big kernel lock, BKL. in linux kernel ）开始， 如果有性能问题再改进 控制流变化时记得获取和释放锁 增加并发并不一定能提高性能 过手锁 Conditional Variable 条件变量： 一个显式队列， 当condition不满足时，线程把自己加入队列，waiting该条件。 当另外某个线程改变该condition时，就可以唤醒signal一个或者多个（假唤醒）等待线程，让它们继续执行\nwait( mutex ): 该函数假定在wait()时， mutex是上锁状态。 wait()的职责是释放锁， 并让调用进程休眠（原子地）。 当线程被唤醒时（在另外某个线程signal它之后）它重新获取锁，再返回调用者\n这样使得wait()写起来很方便：\nPthread_mutex_lock(\u0026amp;m); while(done==0) Pthread_cond_wait(\u0026amp;c,\u0026amp;m);//wait释放锁，线程进入休眠。 当被signal时，wait获取锁，再返回调用者。 不用手写unlock\\lock了 Pthread_mutex_unlock(\u0026amp;m); 总结：signal和wait时总是持有锁 + 需要状态变量\nwait()的语义强制要求调用时已经持有锁，因此不需要操心 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;pthread.h\u0026gt; #include\u0026#34;mythreads.h\u0026#34; #include\u0026lt;stdlib.h\u0026gt; int done = 0; pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t c = PTHREAD_COND_INITIALIZER; void thr_exit() { Pthread_mutex_lock(\u0026amp;m); done = 1; Pthread_cond_signal(\u0026amp;c); Pthread_mutex_unlock(\u0026amp;m); } void thr_join() { Pthread_mutex_lock(\u0026amp;m); while(done==0)// 推荐使用while循环而不是if,原因之后解释 Pthread_cond_wait(\u0026amp;c,\u0026amp;m); Pthread_mutex_unlock(\u0026amp;m); } void * child( void*arg ) { printf( \u0026#34;child\\n\u0026#34; ); thr_exit(); return NULL; } int main( int argc, char* argv[]) { pthread_t p; printf(\u0026#34;parent: begin\\n\u0026#34;); Pthread_create(\u0026amp;p, NULL,child, NULL); thr_join(); printf(\u0026#34;parent: end\\n\u0026#34;); return 0; } 情况一： parent创建出子进程后，自己继续运行（假设单核），然后马上调用thr_join() 等待子进程，此时它会先获取锁，检查子进程是否完成（还没有），然后调用wait()，让自己休眠。 子线程最终得以运行，打印出“child”， 并调用thr_exit()唤醒父进程， 而exit()原子地设置done，向父进程signal， 最后父进程会运行，从wait()返回并持有锁， 释放锁， 打印出“parent: end” 情况二：子进程创建后立刻运行， 设置done = 1， 调用signal()唤醒其他线程（这里没有其他线程），然后结束。 副进程运行后，调用thr_join()时，发现done已经为1了，就直接返回 parent: begin child parent: end 状态变量done是必要的\n假如没有：\nvoid thr_exit() { Pthread_mutex_lock(\u0026amp;m); Pthread_cond_signal(\u0026amp;c); Pthread_mutex_unlock(\u0026amp;m); } void thr_join() { Pthread_mutex_lock(\u0026amp;m); Pthread_cond_wait(\u0026amp;c,\u0026amp;m); Pthread_mutex_unlock(\u0026amp;m); } 假如子线程立刻运行，且调用thr_exit，此时子进程signal()，条件变量上没有睡眠的线程。 父线程运行时，就会调用wait（）并卡在这里，没有线程会signal（）它 发信号和等待时加锁也是必要的\n假如没有：\nvoid thr_exit() { done = 1; Pthread_cond_signal(\u0026amp;c); } void thr_join() { while(done==0)// 推荐使用while循环而不是if,原因之后解释 Pthread_cond_wait(\u0026amp;c,\u0026amp;m); } 如果父进程调用thr_join(),检查done = 0，试图睡眠，然而在调用wait（）前被中断（因为没有锁，此时其它进程就可以操纵临界区）， 子进程修改变量为1,发出signal（），此时没有睡眠进程。 父进程再次运行时，就会卡在wait()，没有线程可以唤醒它 生产者/消费者（有界缓冲区）问题 //30_7.c cond_t cond; mutex_t mutex; int count = 0; void *producer(void *arg) { int i; int loops = (int) arg; for( i=0; i \u0026lt; loops; i++ ) { Pthread_mutex_lock(\u0026amp;mutex); if(count == 1) Pthread_cond_wait(\u0026amp;cond,\u0026amp;mutex); put(i); Pthread_cond_signal(\u0026amp;cond); Pthread_mutex_unlock(\u0026amp;mutex); } } void *consumer( void *arg ) { int i = 0; int loops = (int) arg; for(int i = 0 ; i \u0026lt; loops; i++ ) { pthread_mutex_unlock(\u0026amp;mutex); while( count == 0 )//必须用while,不能用if pthread_cond_wait(\u0026amp;cond,\u0026amp;mutex); int tmp = get(); Pthread_cond_signal(\u0026amp;cond); Pthread_mutex_unlock(\u0026amp;mutex); ptrintf(\u0026#34;%d\\n\u0026#34;,tmp); } } 假设使用if: 假设有两个消费者$T_{c1}$和，$T_{c2}$ 生产者$T_{p}$, 若$T_{c1}$先运行，卡在wait， 接着$T_p$运行，在缓冲区放一个数字，然后signal唤醒$T_{c1}$， 生产者继续循环，直到发现缓冲区满后睡眠 此时如果$T_{c2}$抢先执行，消费了缓冲区里的值，然后$T_{c1}$从wait处恢复运行，调用get，此时发生error！ 原因在于，生产者signal唤醒了$T_{c1}$， 但是没有保证$T_{c1}$立即执行 （或者说，没有保证$T_{c1}$执行之前，缓冲区没有再发生变化） signal的这种语义称为Mesa语义 解决方案是： 始终使用while，这样当$T_{c1}$醒来时，会再次检查count==0，发现为缓冲区0则继续wait。这样就避免了error 使用两个条件变量 上述代码依然有问题： 假设$T_{c1}$和$T_{c2}$先运行，都卡在wait， $T_{p}$开始运行，往缓冲区放入一个值，发出signal， 继续循环，直到发现缓冲区满后睡眠 $T_{c1}$醒来，消费了这个值，然后在该条件上signal，注意，此时理应唤醒$T_{p}$， 但事实上有可能唤醒$T_{c2}$ 假如唤醒$T_{c2}$，因为缓冲区为空， 它会卡在wait，此时三个线程都处于睡眠 原因在于， signal没有指向性， 消费者不应唤醒消费者，只应该唤醒生产者 解决方案：使用两个条件变量， 生产者睡在empty， 消费者睡在fill 由此也看出，线程唤醒需要满足什么条件，它就应该睡在哪个条件变量上，这是条件变量的命名方式 比如消费者需要缓冲区fill才能醒来，因此该条件变量就命名为fill //30_8.c cond_t empty,fill; mutex_t mutex; int count = 0; void *producer(void *arg) { int i; int loops = (int) arg; for( i=0; i \u0026lt; loops; i++ ) { Pthread_mutex_lock(\u0026amp;mutex); if(count == 1) Pthread_cond_wait(\u0026amp;empty,\u0026amp;mutex); put(i); Pthread_cond_signal(\u0026amp;fill); Pthread_mutex_unlock(\u0026amp;mutex); } } void *consumer( void *arg ) { int i = 0; int loops = (int) arg; for(int i = 0 ; i \u0026lt; loops; i++ ) { pthread_mutex_unlock(\u0026amp;mutex); while( count == 0 ) pthread_cond_wait(\u0026amp;fill,\u0026amp;mutex); int tmp = get(); Pthread_cond_signal(\u0026amp;empty); Pthread_mutex_unlock(\u0026amp;mutex); ptrintf(\u0026#34;%d\\n\u0026#34;,tmp); } } 最终版本 这是最终版本，生产者只有缓冲区满了的时候才会睡眠 因此信号量命名为empty有点名不符实（ fill也是如此，事实上缓冲区有一个值就可以唤醒消费者了 ） 对get()和put()的调用保证上了锁 //30_9.c 生产者消费者问题最终版 int buffer[MAX]; int fill_ptr = 0; int use_ptr = 0; int count = 0; void put(int value) { buffer[fill_ptr] = value; fill_ptr = (fill_ptr+1)%MAX; count++; } int get()//拿取use_ptr指向的值，use_ptr++ { int tmp = buffer[use_ptr]; use_ptr = (use_ptr+1)%MAX; count--; return tmp; } cond_t empty,fill; mutex_t mutex; int count = 0; void *producer(void *arg) { int i; int loops = (int) arg; for( i=0; i \u0026lt; loops; i++ ) { Pthread_mutex_lock(\u0026amp;mutex); if(count == MAX) Pthread_cond_wait(\u0026amp;empty,\u0026amp;mutex); put(i); Pthread_cond_signal(\u0026amp;fill); Pthread_mutex_unlock(\u0026amp;mutex); } } void *consumer( void *arg ) { int i = 0; int loops = (int) arg; for(int i = 0 ; i \u0026lt; loops; i++ ) { pthread_mutex_unlock(\u0026amp;mutex); while( count == 0 ) pthread_cond_wait(\u0026amp;fill,\u0026amp;mutex); int tmp = get(); Pthread_cond_signal(\u0026amp;empty); Pthread_mutex_unlock(\u0026amp;mutex); ptrintf(\u0026#34;%d\\n\u0026#34;,tmp); } } 覆盖条件 signal只会唤醒一个线程 考虑一个内存分配程序。 当没有空闲内存时， $T_{c1}$和$T_{c2}$各自allocate1000和10字节。 它们都因此卡在wait 此时$T_{p}$ free了50字节，它发出signal，此时有可能唤醒的是$T_{c1}$， 后者因为内存不够，依然继续睡眠 上述代码因此无法正常工作 解决方案是采用广播的signal, 即pthread_cond_broadcast() 代替pthread_cond_signal,唤醒所有等待线程，这个条件变量称为广播条件covering condition 会影响性能 该方案虽然很笨，但有时很有用 当然，30_8.c的代码也可以采用此解决方案。 但我当时有更好的办法（用两个条件变量） 信号量 def： 有一个整数值的对象，可以用sem_wait()和sem_post()操作（ in Posix ）\n因此要初始化 #include\u0026lt;semaphore.h\u0026gt; sem_t s; sem_init(\u0026amp;s, 0 , 0); 第二个参数一般设为0,表示该信号量在同一个进程的多个线程内贡献 int sem_wait(sem_t *s) { //decrement the value of semaphore s by one //wait if value of semaphore s is a negative } int sem_post(sem_t *s) { //increment the value of semaphore s by one //if there are one or more threads waiting, wake one } 在这个实现中， 信号量的值为负数时，该值就是等待线程的个数\n信号量有时很难设计，此时还是使用条件变量更靠谱\n二值信号量（锁） 可以把信号量作为锁(其值设为1) sem_t m; sem_init(\u0026amp;m, 0, 1); //下文解释为何是1 sem_wait(\u0026amp;m); //critical section sem_post(\u0026amp;m); 假设有两个线程，$T_{1}$调用sem_wait()，将信号量值减为0, 因为0不是负数，因此$T_{c1}$从wait返回并继续，它可以自由进入临界区， 若没有其他线程尝试获取锁，当$T_{1}$调用sem_post()时，会将信号重置为1 如果$T_{1}$持有锁时，$T_{2}$尝试获取锁（即调用sem_wait()），此时它会将信号量减为-1。然后卡在这里。 $T_{1}$再次运行，执行sem_post()， 将信号量值增加到0,唤醒等待的线程（$T_{2}$），然后$T_{2}$就能获取锁 当$T_{2}$执行结束时，执行sem_post()， 将信号量值增加到1 信号量用作条件变量 sem_t s; int count = 0; void *child(void *arg) { printf(\u0026#34;child\\n\u0026#34;); sem_post(\u0026amp;s); return NULL; } int main(int argc, char *argv[]) { sem_init( \u0026amp;s, 0, 0 );//信号量设为0 printf(\u0026#34;parent: begin\\n\u0026#34;); pthread_t c; Pthread_create(c, NULL, child, NULL); sem_wait(\u0026amp;s); // wait here for child printf(\u0026#34;parent: end\\n\u0026#34;); return 0; } 输出为：\nparent: begin child parent: end 考虑两种情况： 子进程没有先运行，父进程先调用sem_wait(),将信号量减为-1,父进程卡在wait， 然后子进程运行，调用sem_post()，信号量增加为0,唤醒父线程 子线程在父线程调用sem_post()之前就运行结束，结果正常 生产者/消费者（有界缓冲区）问题 考虑用信号量实现生产者/消费者问题：\nint buffer[MAX]; int fill_ptr = 0; int use_ptr = 0; int count = 0; void put(int value) { buffer[fill_ptr] = value; fill_ptr = (fill_ptr+1)%MAX; count++; } int get()//拿取use_ptr指向的值，use_ptr++ { int tmp = buffer[use_ptr]; use_ptr = (use_ptr+1)%MAX; count--; return tmp; } sem_t empty,fill; // mutex_t mutex; int count = 0; void *producer(void *arg) { int i; int loops = (int) arg; for( i=0; i \u0026lt; loops; i++ ) { sem_wait(\u0026amp;empty); put(i); sem_post(\u0026amp;fill); } } void *consumer( void *arg ) { int i = 0; int loops = (int) arg; for(int i = 0 ; i \u0026lt; loops; i++ ) { sem_wait(\u0026amp;fill); int tmp = get(); sem_post(\u0026amp;empty); ptrintf(\u0026#34;%d\\n\u0026#34;,tmp); } } 这段代码的问题在于： 对假设MAX大于1,此时可以有两个生产者（$T_1$, $T_2$）同时调用put()，如果$T_1$先放入数据，然后在更新计时器时中断，$T_2$运行，它会在该位置再放入一个值，发生error 这是因为在MAX\u0026gt;1时，信号量的使用不能保证put（）的原子性 解决方案：上锁 int buffer[MAX]; int fill_ptr = 0; int use_ptr = 0; int count = 0; void put(int value) { buffer[fill_ptr] = value; fill_ptr = (fill_ptr+1)%MAX; count++; } int get()//拿取use_ptr指向的值，use_ptr++ { int tmp = buffer[use_ptr]; use_ptr = (use_ptr+1)%MAX; count--; return tmp; } sem_t empty,fill,mutex; int count = 0; void *producer(void *arg) { int i; int loops = (int) arg; for( i=0; i \u0026lt; loops; i++ ) { sem_wait(\u0026amp;mutex); sem_wait(\u0026amp;empty); put(i); sem_post(\u0026amp;mutex); sem_post(\u0026amp;fill); } } void *consumer( void *arg ) { int i = 0; int loops = (int) arg; for(int i = 0 ; i \u0026lt; loops; i++ ) { sem_wait(\u0026amp;mutex); sem_wait(\u0026amp;fill); int tmp = get(); sem_post(\u0026amp;empty); sem_post(\u0026amp;mutex); ptrintf(\u0026#34;%d\\n\u0026#34;,tmp); } } int main() { // ... sem_init(\u0026amp;empty, 0, MAX); sem_init(\u0026amp;fill, 0, 0); sem_init(\u0026amp;mutex, 0, 1);// mutex = 1 because it is a lock //... } 这段代码依然有问题： 因为在fill和empty上睡着时没有释放锁（传统的pthread_wait是会释放锁的，但是这里是用信号量实现的锁）。 因此消费者在fill上睡着时，二值信号量锁mutex没有释放，生产者试图对mutex调用sem_wait也被卡住。\n消费者等待在full，持有mutex， 生产者可以signal fill，却在等待mutex，发生了死锁 解决方案： 把对mutex的获取和释放调整为紧挨着临界区\nint buffer[MAX]; int fill_ptr = 0; int use_ptr = 0; int count = 0; void put(int value) { buffer[fill_ptr] = value; fill_ptr = (fill_ptr+1)%MAX; count++; } int get()//拿取use_ptr指向的值，use_ptr++ { int tmp = buffer[use_ptr]; use_ptr = (use_ptr+1)%MAX; count--; return tmp; } sem_t empty,fill,mutex; int count = 0; void *producer(void *arg) { int i; int loops = (int) arg; for( i=0; i \u0026lt; loops; i++ ) { sem_wait(\u0026amp;empty); sem_wait(\u0026amp;mutex); put(i); sem_post(\u0026amp;mutex); sem_post(\u0026amp;fill) } } void *consumer( void *arg ) { int i = 0; int loops = (int) arg; for(int i = 0 ; i \u0026lt; loops; i++ ) { sem_wait(\u0026amp;fill); sem_wait(\u0026amp;mutex); int tmp = get(); sem_post(\u0026amp;mutex); sem_post(\u0026amp;empty); ptrintf(\u0026#34;%d\\n\u0026#34;,tmp); } } int main() { // ... sem_init(\u0026amp;empty, 0, MAX); sem_init(\u0026amp;fill, 0, 0); sem_init(\u0026amp;mutex, 0, 1);// mutex = 1 because it is a lock //... } 读者 \u0026mdash; 写者锁 读写锁更加灵活，因为查找操作不会更改临界区 typedef struct _rwlock_t { sem_t lock; // binary sephamore, basic lock sem_t writelock;//used to allow ONE writer or MANY readers int readers;// count of readers reading in critical section }rwlock_t; void rwlock_init( rwlock_t *rw ) { rw -\u0026gt; readers = 0; sem_init( \u0026amp;rw -\u0026gt; lock, 0, 1 ); sem_init( \u0026amp;rw -\u0026gt; writelock, 0, 1 ); } void rwlock_acquire_readlock(rwlock_t *rw) { sem_wait(\u0026amp;rw-\u0026gt;lock); rw -\u0026gt; readers++; if(rw-\u0026gt;readers == 1) sem_post( \u0026amp;rw -\u0026gt;writelock ); // last reader releases writelock sem_post(\u0026amp;rw -\u0026gt; lock); } void rwlock_release_readlock(rwlock_t *rw) { sem_wait(\u0026amp;rw-\u0026gt;lock); rw -\u0026gt; readers--; if( rw -\u0026gt; readers == 0 ) sem_post( rw -\u0026gt; writelock );// last reader releases writelock sem_post(\u0026amp;rw-\u0026gt;lock); } void rwlock_acquire_writelock(rwlock_t *rw) { sem_wait(\u0026amp;rw-\u0026gt; writelock); } void rwlock_release_writelock(rwlock_t *rw ) { sem_post(\u0026amp;rw -\u0026gt; writelock); } 想要获取写锁的进程，需要等待所有的读者都结束 缺点：读者很容易饿死写者 哲学家就餐问题 最简单的解决方案：破除依赖， 就是修改某个哲学家的取餐叉顺序\n如何实现信号量 用锁和条件变量实现信号量：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;pthread.h\u0026gt; #include\u0026#34;mythreads.h\u0026#34; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;semaphore.h\u0026gt; typedef struct _Zem_t{ int value; pthread_cond_t cond; pthread_mutex_t lock; }Zem_t; //only one thread can call this void Zem_init(Zem_t *s, int value) { s -\u0026gt; value = value; Pthread_cond_init(\u0026amp;s-\u0026gt;cond,NULL); Pthread_mutex_init(\u0026amp;s-\u0026gt;lock,NULL); } void Zem_wait(Zem_t *s) { Pthread_mutex_lock(\u0026amp;s-\u0026gt;lock); while( s-\u0026gt;value \u0026lt;=0) { Pthread_cond_wait( \u0026amp;s-\u0026gt;cond, \u0026amp;s-\u0026gt;lock ); } s -\u0026gt;value--;//注意到这里是先检查是否为非正数，再递减 Pthread_mutex_unlock(\u0026amp;s-\u0026gt;lock); } void Zem_post(Zem_t *s) { Pthread_mutex_lock(\u0026amp;s-\u0026gt;lock); s -\u0026gt; value++; Pthread_cond_signal( \u0026amp;s -\u0026gt; cond ); Pthread_mutex_unlock(\u0026amp;s-\u0026gt;lock); } 注意到wait是先检查是否为非正数，再递减，这使得信号量值永远不会小于0 这也是linux的实现 用信号量来实现锁和条件变量相当困难 常见并发问题 非死锁缺陷 违反原子性缺陷：给共享变量的访问加锁\n违反顺序缺陷：使用条件变量，强制顺序：\n//... Pthread_mutex_lock(\u0026amp;mutex); while( inited == = ) Pthread_Cond_wait( \u0026amp;cond, \u0026amp;mutex ); //operations to critical section Pthread_mutex_unlock(\u0026amp;mutex); 死锁缺陷 模块化和锁不是很契合 T1 T2 T3 T4 L1 Y Y N N L2 Y Y Y N 系统形成死锁的四个必要条件 互斥条件(mutual exclusion):系统中存在临界资源,进程应互斥地使用这些资源 占有和等待条件(hold and wait):进程请求资源得不到满足而等待时,不释放已占有的资源 不剥夺条件(no preemption):已被占用的资源只能由属主释放,不允许被其它进程剥夺 循环等待条件(circular wait):存在循环等待链,其中,每个进程都在链中等待下一个进程所持有的资源,造成这组进程永远等待 循环等待 细致地设计锁策略，有序加锁 持有并等待 任何线程抢锁之前要先抢一个全局锁，这样保证了抢锁的原子性(抢锁时不会有其他进程切入) 如：假如线程1需要lock1和lock2， 而线程二需要lock2和lock1。线程1获得lock1后不会被打断，能继续获得 lock2，执行完毕，释放这两个锁，线程二继续执行。 lock(prevection);//global lock lock(L1); lock(L2); ... unlock(prevention); 非抢占 top: lock(L1); if(trylock(L2)==-1) { unlock(L1); goto(top); } 同样是实现了原子地抢占锁 如果L2没抢到，那么会释放L1 会导致活锁（ livelock） 两个线程可能一直重复这一序列，又同时都抢锁失败 假如线程1持有lock1，等待lock2( 因此该线程一直try - fail)， 而线程二持有lock2，等待lock1,线程1在试图获得lock2时被中断，线程2获得lock2，试图获得lock1，此时发生活锁 互斥 通过无等待（wait-free）数据结构避免互斥 通过调度避免死锁 线程对锁的需求：\nT1 T2 T3 T4 L1 Y Y N N L2 Y Y Y N 只要T1和T2不同时运行就不会发生死锁 T3只用到一把锁，因此可以和其它线程并发执行，不会死锁 可以强制T2在T1之后运行 这种保守的方案很明显会降低性能 检查和恢复 允许死锁偶尔发生，检查到死锁时再采取行动（重启电脑） 太摆烂了。。。 基于事件的并发（Advanced） 事件循环：\nwhile(1) { events = getEvents(); for( e in events ) { processEvent(e); } } 因为事件是原子的，一次只处理一个事件不需要考虑线程切换。 而且如上所见，我们可以对事件调度进行显式控制 这意味着事件是阻塞的，有巨大的性能开销，需要引入异步的事件处理，再加上多CPU时，并行的事件处理复杂度相当于多线程。 因此给予事件的并发并不比基于线程的简单。 这部分内容很庞大，我不想在C编程上倾注太多时间，因此放在JAVA等语言的并发中讲。 ","permalink":"https://lyk-love.cn/Hugo-Blog/posts/os-concurrency/","posts_num":12,"tags":["机器","操作系统"],"title":"OS Concurrency"}]
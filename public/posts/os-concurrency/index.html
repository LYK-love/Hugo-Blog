<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>OS Concurrency :: LYK-love</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Outline:
Intro： 多处理器编程的困难 用状态机理解并发算法 并发控制：互斥、同步 概念： 互斥 并发与状态机 Threading API Lock Concurrent Data Structure based on Lock Conditional Variable 信号量 常见并发问题 基于事件的并发 Ref：
Operating Systems Three Easy pieces JYY OS " />
<meta name="keywords" content=", " />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://lyk-love.cn/Hugo-Blog/posts/os-concurrency/" />






  
  
  
  
  
  <link rel="stylesheet" href="https://lyk-love.cn/Hugo-Blog/styles.css">







  <link rel="shortcut icon" href="https://lyk-love.cn/images/favicon.ico">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="OS Concurrency">
<meta property="og:description" content="Outline:
Intro： 多处理器编程的困难 用状态机理解并发算法 并发控制：互斥、同步 概念： 互斥 并发与状态机 Threading API Lock Concurrent Data Structure based on Lock Conditional Variable 信号量 常见并发问题 基于事件的并发 Ref：
Operating Systems Three Easy pieces JYY OS " />
<meta property="og:url" content="https://lyk-love.cn/Hugo-Blog/posts/os-concurrency/" />
<meta property="og:site_name" content="LYK-love" />

  
  
  <meta property="og:image" content="https://lyk-love.cn/Hugo-Blog/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">










<style>
     
     
     
     
     
     
     
     
     
     
     



     
     
     
     
     
     

     
     
     
     
     

     
     
     
     
     
     
     
     

     
     
     
     
     
     

     
     
     
     
     

     
     
     
     
     

    #search-btn {
        position: absolute;
        top: 10px;
        right: 20px;
        font: font: inherit;
        font-size: 130%;
        background: inherit;
        border: inherit;
        color: inherit;
    }


</style>




<style>
    .back-to-top {
        box-sizing: border-box;
        border-radius: 8px;        
        position: fixed;
        right: 30px;
        z-index: 1050;
        padding: 0 6px;
        width: initial;
        background: #222;
        font-size: 12px;
        opacity: 0.6;
        color: #fff;
        cursor: pointer;
        text-align: center;
        transition-property: bottom;
        transition-duration: 0.2s;
        transition-timing-function: ease-in-out;
        transition-delay: 0s;
        bottom: -40px;
    }

    .back-top-active {
        bottom: 30px;
    }

    @media (max-width: 767px) {

        .back-to-top {
            right: 10px;
        }


        .back-top-active {
            bottom: 10px;
        }
    }
</style>


<script src="https://kit.fontawesome.com/36e579b0cd.js" crossorigin="anonymous"></script>

<style>
     
    .post-toc {
        position: absolute;
        width: 200px;
        margin-left: 780px;
        padding: 10px;
        word-wrap: break-word;
        box-sizing: border-box;
    .post-toc-title {
        margin: 0;
        font-weight: 400;
        text-transform: uppercase;
    }
    .post-toc-content {
    &.always-active ul {
         display: block;
     }
    >nav>ul {
        margin: 10px 0;
    }
    ul {
        padding-left: 0;
        list-style: none;
    ul {
        padding-left: 15px;
        display: none;
    }
    .has-active > ul {
        display: block;
    }
    }
    }
    a:hover {
        color: #c05b4d;
        -webkit-transform: scale(1.1);
        -ms-transform: scale(1.1);
        transform: scale(1.1);
    }
    a {
        display: block;
        line-height: 30px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        -webkit-transition-duration: .2s;
        transition-duration: .2s;
        -webkit-transition-property: -webkit-transform;
        transition-property: -webkit-transform;
        transition-property: transform;
        transition-property: transform,-webkit-transform;
        -webkit-transition-timing-function: ease-out;
        transition-timing-function: ease-out;
    }
    }
    @media only screen and (max-width: 1224px) {
        .post-toc {
            display: none;
        }
    }
</style>








































</head>
<body class="green">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    LYK-love
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/Hugo-Blog/about">About</a></li>
        
      
        
          <li><a href="/Hugo-Blog/archive">Archive</a></li>
        
      
        
          <li><a href="/Hugo-Blog/tags">Tags</a></li>
        
      
        
          <li><a href="/Hugo-Blog/categories">Categories</a></li>
        
      
        
          <li><a href="/Hugo-Blog/research">Research</a></li>
        
      
        
          <li><a href="/Hugo-Blog/code">Code</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/Hugo-Blog/about" >About</a></li>
        
      
        
          <li><a href="/Hugo-Blog/archive" >Archive</a></li>
        
      
        
          <li><a href="/Hugo-Blog/tags" >Tags</a></li>
        
      
        
          <li><a href="/Hugo-Blog/categories" >Categories</a></li>
        
      
      
        <li>
          <ul class="menu">
            <li class="menu__trigger">Show more&nbsp;▾</li>
            <li>
              <ul class="menu__dropdown">
                
                  
                    <li><a href="/Hugo-Blog/research" >Research</a></li>
                  
                
                  
                    <li><a href="/Hugo-Blog/code" >Code</a></li>
                  
                
              </ul>
            </li>
          </ul>
        </li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://lyk-love.cn/Hugo-Blog/posts/os-concurrency/">OS Concurrency</a>
  </h1>
  <div class="post-meta">
    
    
    
  </div>

  
    <span class="post-tags">
      
      #<a href="https://lyk-love.cn/Hugo-Blog/tags/%E6%9C%BA%E5%99%A8/">机器</a>&nbsp;
      
      #<a href="https://lyk-love.cn/Hugo-Blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#多任务os的并发">多任务OS的并发</a></li>
    <li><a href="#并发与并行的区别">并发与并行的区别</a></li>
    <li><a href="#线程">线程</a></li>
    <li><a href="#多处理器编程的困难">多处理器编程的困难</a>
      <ul>
        <li><a href="#并发术语">并发术语</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#共享内存上互斥的困难">共享内存上互斥的困难</a></li>
  </ul>

  <ul>
    <li><a href="#程序--有限状态机--有向图">程序 = 有限状态机 = 有向图</a></li>
    <li><a href="#状态机模型应用">状态机模型：应用</a>
      <ul>
        <li><a href="#time---travel-debugging">Time - Travel Debugging</a></li>
        <li><a href="#record--replay">Record &amp; Replay</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#相同进程">相同进程</a></li>
    <li><a href="#不同进程">不同进程</a></li>
  </ul>

  <ul>
    <li><a href="#线程创建">线程创建</a></li>
    <li><a href="#线程完成">线程完成</a></li>
    <li><a href="#锁">锁</a></li>
    <li><a href="#条件变量">条件变量</a></li>
  </ul>

  <ul>
    <li><a href="#评价锁">评价锁</a></li>
    <li><a href="#控制中断">控制中断</a></li>
    <li><a href="#test-and-set">test-and-set</a>
      <ul>
        <li><a href="#用test-and-set实现锁">用test-and-set实现锁</a></li>
      </ul>
    </li>
    <li><a href="#compare-and-exchange">compare-and-exchange</a></li>
    <li><a href="#fetch-and-add">fetch-and-add</a></li>
    <li><a href="#自旋过多的解决方案">自旋过多的解决方案</a>
      <ul>
        <li><a href="#方案一--yield">方案一  yield</a></li>
        <li><a href="#方案二-使用队列-休眠代替自旋">方案二 使用队列： 休眠代替自旋</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#并发计数器">并发计数器</a></li>
    <li><a href="#扩展并发计数器">扩展并发计数器</a></li>
    <li><a href="#并发链表">并发链表</a></li>
    <li><a href="#扩展链表">扩展链表</a></li>
    <li><a href="#并发队列">并发队列</a></li>
    <li><a href="#并发散列表">并发散列表</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>

  <ul>
    <li><a href="#生产者消费者有界缓冲区问题">生产者/消费者（有界缓冲区）问题</a>
      <ul>
        <li><a href="#使用两个条件变量">使用两个条件变量</a></li>
      </ul>
    </li>
    <li><a href="#覆盖条件">覆盖条件</a></li>
  </ul>

  <ul>
    <li><a href="#二值信号量锁">二值信号量（锁）</a></li>
    <li><a href="#信号量用作条件变量">信号量用作条件变量</a></li>
    <li><a href="#生产者消费者有界缓冲区问题-1">生产者/消费者（有界缓冲区）问题</a></li>
    <li><a href="#读者-----写者锁">读者 &mdash; 写者锁</a></li>
    <li><a href="#哲学家就餐问题">哲学家就餐问题</a></li>
    <li><a href="#如何实现信号量">如何实现信号量</a></li>
  </ul>

  <ul>
    <li><a href="#非死锁缺陷">非死锁缺陷</a></li>
    <li><a href="#死锁缺陷">死锁缺陷</a>
      <ul>
        <li><a href="#循环等待">循环等待</a></li>
        <li><a href="#持有并等待">持有并等待</a></li>
        <li><a href="#非抢占">非抢占</a></li>
        <li><a href="#互斥">互斥</a></li>
        <li><a href="#通过调度避免死锁">通过调度避免死锁</a></li>
        <li><a href="#检查和恢复">检查和恢复</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <p>Outline:</p>
<ul>
<li>Intro：
<ul>
<li>多处理器编程的困难</li>
<li>用状态机理解并发算法</li>
<li>并发控制：互斥、同步</li>
</ul>
</li>
<li>概念： 互斥</li>
<li>并发与状态机</li>
<li>Threading API</li>
<li>Lock</li>
<li>Concurrent Data Structure based on Lock</li>
<li>Conditional Variable</li>
<li>信号量</li>
<li>常见并发问题</li>
<li>基于事件的并发</li>
</ul>
<p>Ref：</p>
<ul>
<li>Operating Systems Three Easy pieces</li>
<li>JYY OS</li>
</ul>
<h1 id="intro">Intro<a href="#intro" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Concurrent：exsiting, happening, or done at the <em>same</em> time. 程序的不同部分可以按不同顺序执行，且最终得到正确的结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">//t0.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;// pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a // 在编译中要加 -lpthread参数</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">mythread</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>( <span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span>  p1,p2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;main:begin</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ch1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ch2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;B&#34;</span>;
</span></span><span style="display:flex;"><span>    rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_create</span>( <span style="color:#f92672">&amp;</span>p1, NULL, mythread, ch1 ); <span style="color:#a6e22e">assert</span>(rc<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>); <span style="color:#75715e">//C语言编译器允许隐含性的将一个通用指针转换为任意类型的指针，包括const *而C＋＋不允许将const 转换为非const*，所以不能直接传入&#34;A&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_create</span>( <span style="color:#f92672">&amp;</span>p2, NULL, mythread, ch2 ); <span style="color:#a6e22e">assert</span>(rc<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rc<span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_join</span>( p1,NULL );
</span></span><span style="display:flex;"><span>    rc<span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_join</span>( p2,NULL );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;main:end</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该程序打印结果为：</p>
<pre tabindex="0"><code>main:begin
A
B
main:end
</code></pre><p>或者</p>
<pre tabindex="0"><code>main:begin
B
A
main:end
</code></pre><p>两次运行结果不一样</p>
<h2 id="多任务os的并发">多任务OS的并发<a href="#多任务os的并发" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>（假设系统只有一个CPU）</p>
<p>OS可以同时加载多个进程</p>
<ul>
<li>
<p>每个进程都是独立的进程，互不干扰</p>
<ul>
<li>即使是root权限的进程，也不能直接访问操作系统内核的内存</li>
</ul>
</li>
<li>
<p>每隔一段时间，就切换到另一个进程</p>
</li>
</ul>
<hr>
<ul>
<li>并发性的来源： <strong>进程会调用OS的API</strong>
<ul>
<li><code>write（fd,buf,11 TiB）</code>（<code>TiB</code>宏）</li>
<li><code>write</code>的实现是OS的一部分</li>
<li><code>x86-64</code>应用程序执行<code>syscall</code>后就进入OS执行
<ul>
<li>类似中断处理程序</li>
</ul>
</li>
<li>此时OS允许<code>write</code>的同时，让另一个进程执行
<ul>
<li>如：另一个进程执行了<code>read(fd,buf,512 MiB)</code>读取同一文件</li>
<li><strong>OS代码并发了</strong>： <code>OS API</code>实现需要考虑并发
<ul>
<li>虽然进程在地址空间中是独立的，但是OS中的对象是被进程共享的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="并发与并行的区别">并发与并行的区别<a href="#并发与并行的区别" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>并发： 多个执行流可以不按照一个特定的顺序执行</li>
<li>并行：允许多个执行流真正地同时执行
<ul>
<li>需要多个处理器</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>处理器数量</th>
<th>共享内存？</th>
<th>典型的并发OS</th>
<th>并发？并行？</th>
</tr>
</thead>
<tbody>
<tr>
<td>单</td>
<td>共享内存</td>
<td>OS内核/多线程程序</td>
<td>并发不并行</td>
</tr>
<tr>
<td>多</td>
<td>共享内存</td>
<td>OS内核/多线程程序/GPU Kernel</td>
<td>并发、并行</td>
</tr>
<tr>
<td>多</td>
<td>不共享内存</td>
<td>分布式系统（消息通信）</td>
<td>并发、并行</td>
</tr>
</tbody>
</table>
<h2 id="线程">线程<a href="#线程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>线程： A single process can contain multiple threads, all of  which  are  executing  the same  program.   These  threads <strong>share</strong> the same global memory (data and heap segments), but each thread has its own stack (automatic variables).</p>
<p>多个执行流并发/并行执行，且<strong>共享内存</strong></p>
<ul>
<li>两个执行流共享代码和所有全局变量（数据区、堆区）
<ul>
<li>i.e. C++中，数据区就是全局/静态区</li>
</ul>
</li>
<li>线程间指令的执行顺序是不确定（<em>non-deterministic</em>）的</li>
<li>共享：共享代码区(当前进程的代码)、数据区和堆，但不共享寄存器和栈</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//t1.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//共享全局变量的后果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;mythreads.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">mythread</span>( <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;%s: begin</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)arg );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1e7</span>; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s: done</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)arg);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>( <span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span>  p1,p2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;main:begin ( counter = %d )</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, counter );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ch1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ch2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;B&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_create</span>( <span style="color:#f92672">&amp;</span>p1, NULL, mythread, ch1 ); <span style="color:#75715e">//C语言编译器允许隐含性的将一个通用指针转换为任意类型的指针，包括const *而C＋＋不允许将const 转换为非const*，所以不能直接传入&#34;A&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Pthread_create</span>( <span style="color:#f92672">&amp;</span>p2, NULL, mythread, ch2 ); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_join</span>( p1,NULL );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_join</span>( p2,NULL );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;main:done with both ( counter = %d )</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, counter);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//mythreads.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//把API封装起来，易于使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// #include&lt;assert.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_create</span> (<span style="color:#66d9ef">pthread_t</span> <span style="color:#f92672">*</span>__restrict __newthread,
</span></span><span style="display:flex;"><span>			   <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> __attr,
</span></span><span style="display:flex;"><span>			   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>__start_routine) (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>),
</span></span><span style="display:flex;"><span>			   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__restrict __arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_create</span>( __newthread, __attr, __start_routine, __arg );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_join</span>(<span style="color:#66d9ef">pthread_t</span> __th, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>__thread_return)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">pthread_join</span>( __th, __thread_return );
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Malloc</span>(<span style="color:#66d9ef">unsigned</span> size)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">malloc</span>(size);
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>输出为：</p>
<pre tabindex="0"><code>main:begin ( counter = 0 )
A: begin
B: begin
A: done
B: done
main:done with both ( counter = 12275324 )
</code></pre><p>可以看到结果不是200000, 而是12275324</p>
<p>再运行一次：</p>
<pre tabindex="0"><code>main:begin ( counter = 0 )
A: begin
B: begin
B: done
A: done
main:done with both ( counter = 10467369 )
</code></pre><p><strong>两次运行的结果都不一样！</strong></p>
<h2 id="多处理器编程的困难">多处理器编程的困难<a href="#多处理器编程的困难" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>原子性： 即使是<code>i++</code>，也会被分成几个指令</li>
<li>顺序性：<strong>代码</strong>的编译器优化</li>
<li>可见性： <strong>CPU</strong>可以不按顺序执行指令。没有前后依赖就会被优化（并行执行）</li>
</ul>
<h3 id="并发术语">并发术语<a href="#并发术语" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>临界区( <code>critical section</code> )： 访问共享资源的一段代码</li>
<li>竞态条件( <code>race condition</code> )： 多个执行线程大致同时进入进阶区时，都试图更新共享资源的情况</li>
<li>不确定性( <code>indeterminate</code> )： 程序含有竞态条件，其输出不确定</li>
<li>同步原语( <code>synchronization primitive</code> ):硬件提供指令，在其上构建同步原语,实现<strong>原子性</strong></li>
<li>互斥原语( <code>mutual exclusion</code> )： 线程应该使用互斥原语，以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出</li>
</ul>
<h1 id="概念互斥">概念：互斥<a href="#概念互斥" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>互斥（mutual exclusion）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>}lock_tl
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>(<span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>lk);<span style="color:#75715e">//试图获得锁的独占访问，成功获得后返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>(<span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>lk);<span style="color:#75715e">//释放锁的独占空间
</span></span></span></code></pre></div><p>我们假设CPU有三种指令：</p>
<ol>
<li>load： mem -&gt; reg</li>
<li>store: reg -&gt; mem</li>
<li>本地计算： 线程的寄存器做一些计算，结果存入寄存器</li>
</ol>
<h2 id="共享内存上互斥的困难">共享内存上互斥的困难<a href="#共享内存上互斥的困难" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>
<p>load和store的缺陷（一个只能看，一个只能写）</p>
</li>
<li>
<p>现代处理器load/store可能在执行时被乱序</p>
</li>
</ul>
<h1 id="并发与状态机">并发与状态机<a href="#并发与状态机" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="程序--有限状态机--有向图">程序 = 有限状态机 = 有向图<a href="#程序--有限状态机--有向图" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>图论是理解程序的重要工具</p>
<p>不确定(non-deterministic)的指令可能有多个状态</p>
<ul>
<li>
<p>获取处理器的”时间戳“用于精确定时</p>
<ul>
<li><code>rdtsc/rdtscp</code></li>
</ul>
</li>
<li>
<p>机器提供的”真“随机数</p>
<ul>
<li><code>rdrand</code></li>
</ul>
</li>
<li>
<p><code>syscall</code></p>
<ul>
<li>一般用于唯一不确定性的来源</li>
<li><code>read</code></li>
</ul>
</li>
</ul>
<h2 id="状态机模型应用">状态机模型：应用<a href="#状态机模型应用" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>在硬件上的应用： 高性能处理器实现
<ul>
<li>超标量处理器
<ul>
<li>同一时间执行多条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="time---travel-debugging">Time - Travel Debugging<a href="#time---travel-debugging" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>
<p>程序执行随时间渐进：$s_0 \rarr s_1 \rarr \dots$​</p>
</li>
<li>
<p>记录所有$s_i$的开销太大（$s_i$​由内存和寄存器组成）</p>
</li>
<li>
<p><strong>记录初始状态，和每条指令前后状态的diff</strong></p>
</li>
<li>
<p><code>si/rsi</code></p>
</li>
</ul>
<h3 id="record--replay">Record &amp; Replay<a href="#record--replay" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>确定的程序不需要任何记录，只需要再执行一次</p>
<ul>
<li>只需记录non-deterministic指令的<strong>效果</strong>（side-effect），就可实现重放</li>
</ul>
<h1 id="线程间通信itc">线程间通信ITC<a href="#线程间通信itc" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>(1)通信线程位于同一个进程中，共享相同的地址空间</p>
<p>(2)通信线程位于不同的进程中，拥有不同的地址空间</p>
<h2 id="相同进程">相同进程<a href="#相同进程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>对于情况(1)，线程间的通信可以直接通过<em>访问共享的地址空间</em>实现信息交换</p>
<h2 id="不同进程">不同进程<a href="#不同进程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>对于情况(2), 采用进程间通信IPC</p>
<p>• IPC机制主要包括:信号(Signal)、管道(Pipe)、信号量、共享内存(Shared Memory)、消息队列(Message Queue)、套接字(Socket)</p>
<p>• 与线程间通信机制不同，进程间通信机制需要打破进程间地址空间的隔离</p>
<p>某些OS发行版(.其实就是欧拉 )增加的IPC机制：共享内存， 消息通信</p>
<ul>
<li>共享内存是一种在进程间高效地传递大量信息的通信方式。但在共享内存机制下，信息的发送方不关心信息由谁接收，而信息的接收方也不关心信息是由谁发送的，这存在安全隐患。</li>
<li>消息传递允许进程不必通过共享内存区来实现通信，而是通过交换消息的方式来实现通信。消息 传递关注信息的发送者不接收者，通过使用内核拷贝传递的信息，完成进程间的信息传递</li>
</ul>
<p><img src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Concurrency/shared%20memory.png" alt="image-20220408144852516"></p>
<h1 id="threading-api">Threading API<a href="#threading-api" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p><code>man  -k pthread</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">//p212, 线程API
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;mythreads.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">myarg_t</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>}<span style="color:#66d9ef">myarg_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">myret_t</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>}<span style="color:#66d9ef">myret_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">mythread</span>( <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">myarg_t</span> <span style="color:#f92672">*</span>m <span style="color:#f92672">=</span> (<span style="color:#66d9ef">myarg_t</span> <span style="color:#f92672">*</span>)arg;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;args: %d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,  m <span style="color:#f92672">-&gt;</span> a, m <span style="color:#f92672">-&gt;</span> b );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">myret_t</span> <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> <span style="color:#a6e22e">Malloc</span>(<span style="color:#66d9ef">sizeof</span>( <span style="color:#66d9ef">myret_t</span> ));
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">-&gt;</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>( <span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span>  p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">myret_t</span> <span style="color:#f92672">*</span>m; <span style="color:#75715e">//将返回值打包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">myarg_t</span> args;<span style="color:#75715e">//将参数打包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    args.a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    args.b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_create</span>( <span style="color:#f92672">&amp;</span>p, NULL, mythread, <span style="color:#f92672">&amp;</span>args ); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_join</span>( p, ( <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>) <span style="color:#f92672">&amp;</span>m );<span style="color:#75715e">//将线程返回值赋给m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;returned: %d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, m <span style="color:#f92672">-&gt;</span> x, m <span style="color:#f92672">-&gt;</span> y );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出为：</p>
<pre tabindex="0"><code>args: 10 20
returned: 1 2
</code></pre><h2 id="线程创建">线程创建<a href="#线程创建" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><code> &lt;pthread.h&gt;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Create a new thread, starting with execution of START-ROUTINE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   getting passed ARG.  Creation attributed come from ATTR.  The new
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   handle is stored in *NEWTHREAD.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_create</span> (<span style="color:#66d9ef">pthread_t</span> <span style="color:#f92672">*</span>__restrict __newthread, <span style="color:#75715e">//线程的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			   <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">pthread_attr_t</span> <span style="color:#f92672">*</span>__restrict __attr, <span style="color:#75715e">//线程具有的属性，包括栈大小，优先级等。 一般传入NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>__start_routine) (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>),<span style="color:#75715e">//线程要运行的函数的指针，接受void*参数，返回 void* //可以自由更改参数/返回类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__restrict __arg) __THROWNL <span style="color:#a6e22e">__nonnull</span> ((<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>));<span style="color:#75715e">//函数的参数，可传入结构体，以实现传入多个参数
</span></span></span></code></pre></div><h2 id="线程完成">线程完成<a href="#线程完成" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Make calling thread wait for termination of the thread TH.  The
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   is not NULL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   This function is a cancellation point and therefore not marked with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   __THROW.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_join</span> (<span style="color:#66d9ef">pthread_t</span> __th, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>__thread_return);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">第一个参数是线程的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">第二个参数是线程运行的函数的返回值的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><h2 id="锁">锁<a href="#锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//上锁和解锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_mutex_lock</span> (<span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__mutex)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_mutex_unlock</span> (<span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__mutex)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//锁必须初始化，两种方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pthread_mutex_t</span> lock <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">*</span>lock, NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//锁使用完后必须销毁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_mutex_destroy</span> (<span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__mutex)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//mythread.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#66d9ef">cond_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#66d9ef">mutex_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_create</span> (<span style="color:#66d9ef">pthread_t</span> <span style="color:#f92672">*</span>__restrict __newthread,
</span></span><span style="display:flex;"><span>			   <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> __attr,
</span></span><span style="display:flex;"><span>			   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>__start_routine) (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>),
</span></span><span style="display:flex;"><span>			   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__restrict __arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_create</span>( __newthread, __attr, __start_routine, __arg );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_join</span>(<span style="color:#66d9ef">pthread_t</span> __th, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>__thread_return)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_join</span>( __th, __thread_return );
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Malloc</span>(<span style="color:#66d9ef">unsigned</span> size)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">malloc</span>(size);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_mutex_lock</span>( <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>mutex )
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_mutex_lock</span>(mutex);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_mutex_unlock</span>( <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>mutex )
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_mutex_unlock</span>(mutex);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_mutex_init</span>( <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__mutex,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>__mutexattr )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_mutex_init</span>(__mutex, NULL);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_mutex_destroy</span>( <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__mutex )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_mutex_destroy</span>(__mutex);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_cond_init</span>( <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__restrict __cond,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>__restrict __cond_attr )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_cond_init</span>( __cond, __cond_attr);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cond_destroy</span>( <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__restrict __cond )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_cond_destroy</span>(__cond);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__restrict __cond,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__restrict __mutex)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_cond_wait</span>(__cond, __mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(rc <span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__cond)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_cond_signal</span>(__cond);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>( rc<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_mutex_t</span> lock;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_init</span>( <span style="color:#f92672">&amp;</span>lock ,NULL );<span style="color:#75715e">//初始化锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_lock</span>( <span style="color:#f92672">&amp;</span>lock );<span style="color:#75715e">//上锁， 如果锁已经被其他线程持有，那么该调用不会返回，直到获得该锁（意味着持有该锁的线程已经将锁释放）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_unlock</span>( <span style="color:#f92672">&amp;</span>lock );
</span></span></code></pre></div><h2 id="条件变量">条件变量<a href="#条件变量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Wait for condition variable COND to be signaled or broadcast.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   MUTEX is assumed to be locked before.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   This function is a cancellation point and therefore not marked with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   __THROW.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_cond_wait</span> (<span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__restrict __cond,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>__restrict __mutex);
</span></span><span style="display:flex;"><span>			      
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Wake up one thread waiting for condition variable COND.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_cond_signal</span> (<span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__cond);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//条件变量也必须初始化，与锁类似，两种方式： 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pthread_cond_t</span> cond <span style="color:#f92672">=</span> PTHREAD_COND_INITIALIZER;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_cond_init</span>( __cond, __cond_attr);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">//销毁也类似
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* Destroy condition variable COND.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_cond_destroy</span> (<span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__cond);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//mythreads.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pthread_cond_init</span>( <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__restrict __cond,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>__restrict __cond_attr )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_cond_init</span>( __cond, __cond_attr);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cond_destroy</span>( <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>__restrict __cond )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_cond_destroy</span>(__cond);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">assert</span>( rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="lock">Lock<a href="#lock" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>
<p>锁的状态：</p>
<ul>
<li><code>available</code></li>
<li><code>acquired</code></li>
</ul>
</li>
<li>
<p>方法：</p>
<ul>
<li><code>lock()</code>: 尝试获取锁，如果锁是<code>available</code>，则获取锁，进入临界区</li>
<li><code>unlock()</code>: 使锁<code>available</code></li>
</ul>
</li>
<li>
<p>锁提供了最小程度的调度控制</p>
<ul>
<li>线程由OS调度， 锁让程序员获得了一些控制权</li>
</ul>
</li>
<li>
<p>通常用不同的锁保护不同的数据（ 细粒度的方案 ）</p>
</li>
</ul>
<h2 id="评价锁">评价锁<a href="#评价锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>有效性： 提供互斥</li>
<li>公平性<code>fairness</code>:  当锁可用时，是否每一个竞争线程有公平的机会抢到锁
<ul>
<li>是否有竞争锁的线程会饿死<code>starve</code>?</li>
</ul>
</li>
<li>性能<code> performance</code></li>
</ul>
<h2 id="控制中断">控制中断<a href="#控制中断" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>最早提供的互斥解决方案之一，就是在临界区关闭中断：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">DisableInterrupts</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">EnableInterrupts</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>假设在单CPU系统上，这段代码在临界区关闭中断，从而原子地执行，结束后又重新打开中断</p>
<ul>
<li>
<p>缺点：</p>
<ul>
<li>需要允许所有线程执行特权操作（开关中断）
<ul>
<li>即，需要信任机制不被滥用</li>
</ul>
</li>
<li>不支持多处理器
<ul>
<li>中断的开关只是对CPU而言，如果一个多个线程运行在不同CPU上，其中一个CPU关闭中断，其他CPU依然响应中断，在其上的线程依然能进入临界区</li>
</ul>
</li>
<li>关中断导致<strong>中断丢失</strong>，可能导致严重的系统问题
<ul>
<li>比如磁盘完成了读取请求，但CPU错失了该消息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>因此，用<strong>关中断来实现互斥原语</strong>的情况很有限</p>
<ul>
<li>有些情况下OS自身会采用关中断的方式来保证访问数据的原子性，此时该用法是可行的，因为OS内部不存在信任问题</li>
</ul>
</li>
<li>
<p>很多人热衷于研究不依赖硬件实现的锁机制，事实证明，只需很少的硬件支持，实现锁就会容易很多</p>
</li>
</ul>
<h2 id="test-and-set">test-and-set<a href="#test-and-set" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>
<p><code>test-and-set instruction</code>,  也称为<code>atomic exchange</code>,  由硬件支持</p>
</li>
<li>
<p>先实现一个不依赖它的锁：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//想法是： 用一个flag来表示锁是否被占用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">lock_t</span>( <span style="color:#66d9ef">int</span> flag; ) <span style="color:#66d9ef">lock_t</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>( <span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>mutex )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mutex <span style="color:#f92672">-&gt;</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 0 -&gt; lock is available
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>( <span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>mutex )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>( mutex <span style="color:#f92672">-&gt;</span> flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>        ; <span style="color:#75715e">// spin-wait( do nothing )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mutex <span style="color:#f92672">-&gt;</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>( <span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>mutex )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mutex <span style="color:#f92672">-&gt;</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>这段代码有两个问题：</p>
<ul>
<li>
<p>正确性：</p>
<table>
<thead>
<tr>
<th>Thread`</th>
<th>Thread2</th>
</tr>
</thead>
<tbody>
<tr>
<td>( 初始时，flag == 0 )  call lock()</td>
<td></td>
</tr>
<tr>
<td>while( flag == 1 )</td>
<td></td>
</tr>
<tr>
<td>interrupt: switch to Thread2</td>
<td></td>
</tr>
<tr>
<td></td>
<td>call lock()</td>
</tr>
<tr>
<td></td>
<td>while( flag == 1 )</td>
</tr>
<tr>
<td></td>
<td><strong>flag = 1;</strong></td>
</tr>
<tr>
<td></td>
<td>interrupt: switch to Thread 1</td>
</tr>
<tr>
<td><strong>flag = 1( too ! )</strong></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>性能问题：</p>
<ul>
<li>这个锁是<strong>自旋</strong>的，一个线程自旋等待另一个线程释放锁，浪费时间
<ul>
<li>对于单CPU，因为同一时间只有一个线程，且自旋的线程永远不会放弃CPU,本线程自旋时，持有锁的线程根本无法运行，也不可能释放锁
<ul>
<li>需要抢占式的调度器（ <code> preemptive scheduler</code> , 即不断通过时钟中断一个线程，运行其他线程 )</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="用test-and-set实现锁">用test-and-set实现锁<a href="#用test-and-set实现锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>在x86上称为 <code>xchg</code>指令，</li>
</ul>
<pre><code>```c
int TestAndSet( int *old_ptr, int new )
{
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}// 返回old_ptr指向的旧值，将old_ptr指向新值
```

硬件保证，上述操作是原子的
</code></pre>
<ul>
<li>
<p>可以理解为：一个厕所门上挂着钥匙(<code>0</code>)，两个用户都有一个名牌(<code>1</code>)，用户每次进出厕所，需要拿手上的东西和门上的东西交换，用户需要拿到钥匙才能进厕所。</p>
<ul>
<li>
<p>用户一拿名牌和钥匙交换，拿着钥匙进了厕所</p>
</li>
<li>
<p>用户二拿名牌交换，此时门上是名牌，用户二没有拿到钥匙，无法进厕所</p>
<ul>
<li>
<p>他会一直交换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>( <span style="color:#a6e22e">TestAndSet</span>( <span style="color:#f92672">&amp;</span>lock <span style="color:#f92672">-&gt;</span> flag, <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>	; <span style="color:#75715e">//spin
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>用户一从厕所出来，拿名牌和手上的钥匙交换，此时门上又有钥匙了</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>如上述</li>
</ul>
</li>
<li>
<p>评价自旋锁：</p>
<ul>
<li>有效性：OK
<ul>
<li>公平性：不提供任何公平性保证( 对<code>test-and-set</code>而言 )</li>
<li>性能： 单核下很差，多核下还不错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="compare-and-exchange">compare-and-exchange<a href="#compare-and-exchange" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>
<p>某些系统提供了另一个硬件原语: <code>compare-and-exchange</code>( on x86 )</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//返回ptr指向的旧值，将ptr指向新值（如果旧值与期望值相等的话）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">CompareAndExchange</span>(  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr, <span style="color:#66d9ef">int</span> expected, <span style="color:#66d9ef">int</span> new )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> actual <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>( actual <span style="color:#f92672">==</span> expected )
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> actual;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该指令比<code>test-and-set</code>更强大</p>
</li>
</ul>
<h2 id="fetch-and-add">fetch-and-add<a href="#fetch-and-add" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FetchAndAdd</span>( <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> old <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> old <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> old;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">lock_t</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ticket;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> turn;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">lock_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock_init</span>( <span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>lock )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    lock <span style="color:#f92672">-&gt;</span> ticket <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    lock <span style="color:#f92672">-&gt;</span> turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>(<span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> myturn <span style="color:#f92672">=</span> <span style="color:#a6e22e">FetchAndAdd</span>( <span style="color:#f92672">&amp;</span>lock<span style="color:#f92672">-&gt;</span>ticket );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>( lock<span style="color:#f92672">-&gt;</span> turn <span style="color:#f92672">!=</span> myturn )
</span></span><span style="display:flex;"><span>        ; <span style="color:#75715e">//spin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>( <span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>lock )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FetchAndAdd</span>( <span style="color:#f92672">&amp;</span>lock<span style="color:#f92672">-&gt;</span> turn );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>解释：<code>ticket</code>是一个全局的号码，<code>turn</code>是全局的轮次。 每个用户从ticket得到自己的<code>turn</code>， 每交易一次，<code>ticket++</code>. 只有到达自己的turn的用户才能进入临界区，每当一个用户从临界区出来， <code>turn++</code></p>
<ul>
<li><code>myturn &lt; turn</code>的用户只能自旋</li>
</ul>
</li>
<li>
<p>本方法能保证所有线程都能抢到锁，只要一个线程获得了<code>ticket</code>，就能被调度</p>
<ul>
<li><code>test-and-set</code>无法保证</li>
</ul>
</li>
</ul>
<h2 id="自旋过多的解决方案">自旋过多的解决方案<a href="#自旋过多的解决方案" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>我们已经实现了有效、公平（ 借助<code>ticket</code>）的锁，但自旋会导致性能降低
<ul>
<li>自旋会重复检查一个不会改变的值，浪费CPU时间</li>
</ul>
</li>
</ul>
<h3 id="方案一--yield">方案一  yield<a href="#方案一--yield" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>在要自旋的时候，放弃CPU</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>( <span style="color:#a6e22e">TestAndSet</span>(<span style="color:#f92672">&amp;</span>flag, <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">yield</span>(); <span style="color:#75715e">//give up the CPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>假定OS提供原语<code>yield()</code>，可以让线程从<code>running</code>变为<code>ready</code>
<ul>
<li>本质上，就是<code>deschedule</code></li>
</ul>
</li>
<li>假设100个线程竞争1个锁，该方案会<code>yield</code>99次，比自旋99次好，但仍不够完美</li>
</ul>
<h3 id="方案二-使用队列-休眠代替自旋">方案二 使用队列： 休眠代替自旋<a href="#方案二-使用队列-休眠代替自旋" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">lock_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>        <span style="color:#66d9ef">int</span> flag;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>        <span style="color:#66d9ef">int</span> guard;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>        <span style="color:#66d9ef">queue_t</span> <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>    } <span style="color:#66d9ef">lock_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock_init</span>(<span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>m) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>        m<span style="color:#f92672">-&gt;</span>flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>        m<span style="color:#f92672">-&gt;</span>guard <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span>       <span style="color:#a6e22e">queue_init</span>(m<span style="color:#f92672">-&gt;</span>q);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>(<span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>m) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">14</span>       <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">TestAndSet</span>(<span style="color:#f92672">&amp;</span>m<span style="color:#f92672">-&gt;</span>guard, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span>           ; <span style="color:#75715e">//acquire guard lock by spinning
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">16</span>       <span style="color:#66d9ef">if</span> (m<span style="color:#f92672">-&gt;</span>flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>           m<span style="color:#f92672">-&gt;</span>flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// lock is acquired
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">18</span>           m<span style="color:#f92672">-&gt;</span>guard <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>       } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20</span>           <span style="color:#a6e22e">queue_add</span>(m<span style="color:#f92672">-&gt;</span>q, <span style="color:#a6e22e">gettid</span>());
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>           m<span style="color:#f92672">-&gt;</span>guard <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>           <span style="color:#a6e22e">park</span>();
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">23</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">24</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">26</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>(<span style="color:#66d9ef">lock_t</span> <span style="color:#f92672">*</span>m) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">27</span>       <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">TestAndSet</span>(<span style="color:#f92672">&amp;</span>m<span style="color:#f92672">-&gt;</span>guard, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">28</span>           ; <span style="color:#75715e">//acquire guard lock by spinning
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">29</span>       <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">queue_empty</span>(m<span style="color:#f92672">-&gt;</span>q))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30</span>           m<span style="color:#f92672">-&gt;</span>flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// let go of lock; no one wants it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">31</span>       <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>           <span style="color:#a6e22e">unpark</span>(<span style="color:#a6e22e">queue_remove</span>(m<span style="color:#f92672">-&gt;</span>q)); <span style="color:#75715e">// hold lock (for next thread!)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">33</span>       m<span style="color:#f92672">-&gt;</span>guard <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">34</span>   }
</span></span></code></pre></div><p>看不懂QAQ,为啥unpark的时候不把flag设为0啊，这样所有其他进程都无法获得锁</p>
<h1 id="concurrent-data-structure-based-on-lock">Concurrent Data Structure Based on Lock<a href="#concurrent-data-structure-based-on-lock" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>通过锁使得数据<code>thread safe</code></li>
<li>可扩展性： 理想状态下的多线程的每个线程就和单线程一样快，二者的比值就是并发方法的<strong>扩展性</strong></li>
</ul>
<h2 id="并发计数器">并发计数器<a href="#并发计数器" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">counter_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>        <span style="color:#66d9ef">int</span>            value;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>        <span style="color:#66d9ef">pthread_mutex_t</span> lock;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>    } <span style="color:#66d9ef">counter_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>        c<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>        <span style="color:#a6e22e">Pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock,  NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>    }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>       <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>       c<span style="color:#f92672">-&gt;</span>value<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">14</span>       <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">decrement</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span>       <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>       c<span style="color:#f92672">-&gt;</span>value<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20</span>       <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">23</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">24</span>       <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">25</span>       <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">26</span>       <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">27</span>       <span style="color:#66d9ef">return</span> rc;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">28</span>   }
</span></span></code></pre></div><ul>
<li>性能一般</li>
</ul>
<h2 id="扩展并发计数器">扩展并发计数器<a href="#扩展并发计数器" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>
<p>懒惰计数器<code>sloopy counter</code>:  例如，在4CPU机器上，有四个局部计数器和一个全局计数器，每个计数器有一把锁。</p>
<ul>
<li>不同CPU上的计数器不会竞争</li>
<li>为了保持全局计数器更新，如果局部值大于阈值S，局部值就要转移到全局值（此时要获取全局锁）
<ul>
<li>阈值越大，可扩展性越好，但计时器精度更低</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">counter_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>        <span style="color:#66d9ef">int</span>             global;            <span style="color:#75715e">// global count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span>        <span style="color:#66d9ef">pthread_mutex_t</span> glock;             <span style="color:#75715e">// global lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span>        <span style="color:#66d9ef">int</span>             local[NUMCPUS];    <span style="color:#75715e">// local count (per cpu)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">5</span>        <span style="color:#66d9ef">pthread_mutex_t</span> llock[NUMCPUS];    <span style="color:#75715e">// ... and locks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">6</span>        <span style="color:#66d9ef">int</span>             threshold;         <span style="color:#75715e">// update frequency
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">7</span>    } <span style="color:#66d9ef">counter_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>    <span style="color:#75715e">// init: record threshold, init locks, init values
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">10</span>   <span style="color:#75715e">//       of all local counts and global count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">11</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c, <span style="color:#66d9ef">int</span> threshold) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>       c<span style="color:#f92672">-&gt;</span>threshold <span style="color:#f92672">=</span> threshold;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">14</span>       c<span style="color:#f92672">-&gt;</span>global <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span>       <span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>glock,  NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>       <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span>       <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUMCPUS; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>           c<span style="color:#f92672">-&gt;</span>local[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20</span>           <span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>llock[i],  NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">24</span>   <span style="color:#75715e">// update: usually, just grab local lock and update local amount
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">25</span>   <span style="color:#75715e">//        once local count has risen by &#39;threshold&#39;, grab global
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">26</span>   <span style="color:#75715e">//        lock and transfer local values to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">27</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c, <span style="color:#66d9ef">int</span> threadID, <span style="color:#66d9ef">int</span> amt) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">28</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>llock[threadID]);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">29</span>       c<span style="color:#f92672">-&gt;</span>local[threadID] <span style="color:#f92672">+=</span> amt;               <span style="color:#75715e">// assumes amt &gt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">30</span>       <span style="color:#a6e22e">if</span> (c<span style="color:#f92672">-&gt;</span>local[threadID] <span style="color:#f92672">&gt;=</span> c<span style="color:#f92672">-&gt;</span>threshold) { <span style="color:#75715e">// 局部值大于阈值，transfer to global
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">31</span>           <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>glock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>           c<span style="color:#f92672">-&gt;</span>global <span style="color:#f92672">+=</span> c<span style="color:#f92672">-&gt;</span>local[threadID];
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">33</span>           <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>glock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">34</span>           c<span style="color:#f92672">-&gt;</span>local[threadID] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//本地值清0, 注意到不会与其他cpu上的线程竞争，因此是安全的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">35</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">36</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>llock[threadID]);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">37</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">38</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">39</span>   <span style="color:#75715e">// get: just return global amount (which may not be perfect)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">40</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">counter_t</span> <span style="color:#f92672">*</span>c) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">41</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>glock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">42</span>       <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>global;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">43</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>c<span style="color:#f92672">-&gt;</span>glock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">44</span>       <span style="color:#66d9ef">return</span> val; <span style="color:#75715e">// only approximate!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">45</span>   }
</span></span></code></pre></div><h2 id="并发链表">并发链表<a href="#并发链表" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>    <span style="color:#75715e">// basic node structure，单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">node_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>        <span style="color:#66d9ef">int</span>                key;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>        <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">node_t</span>        <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>    } <span style="color:#66d9ef">node_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>    <span style="color:#75715e">// basic list structure (one used per list)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">8</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">list_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>        <span style="color:#66d9ef">node_t</span>                <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span>       <span style="color:#66d9ef">pthread_mutex_t</span>    lock;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span>   } <span style="color:#66d9ef">list_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">List_Init</span>(<span style="color:#66d9ef">list_t</span> <span style="color:#f92672">*</span>L) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">14</span>       L<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span>       <span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock,  NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">List_Insert</span>(<span style="color:#66d9ef">list_t</span> <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>new <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">node_t</span>));
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>       <span style="color:#66d9ef">if</span> (new <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>           <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;malloc&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">23</span>           <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock); <span style="color:#75715e">//malloc失败，记得释放锁！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">24</span>           <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// fail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">25</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">26</span>       new<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">27</span>       new<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">28</span>       L<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">29</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30</span>       <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// success
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">31</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">33</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">List_Lookup</span>(<span style="color:#66d9ef">list_t</span> <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">34</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">35</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>curr <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">36</span>       <span style="color:#66d9ef">while</span> (curr) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">37</span>           <span style="color:#66d9ef">if</span> (curr<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">38</span>               <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock); <span style="color:#75715e">//在意外退出时unlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">39</span>               <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// success
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">40</span>           }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">41</span>           curr <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">42</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">43</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">44</span>       <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// failure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">45</span>   }
</span></span></code></pre></div><ul>
<li>在开头lock,结尾unlock, 注意到<code>malloc</code>失败后也要记得unlock
<ul>
<li>这种在代码中多次unlock的写法很丑陋！ 应该修改
<ul>
<li>要么出错的地方不要放在临界区</li>
<li>要么出错时break到主循环，在主循环内统一unlock</li>
</ul>
</li>
</ul>
</li>
<li>这是粗粒度的写法，可以更细粒度地优化：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">18</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">List_Insert</span>(<span style="color:#66d9ef">list_t</span> <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>      <span style="color:#75715e">//local的数据，不需要锁保护
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">20</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>new <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">node_t</span>));
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>       <span style="color:#66d9ef">if</span> (new <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>           <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;malloc&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">23</span>           <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock); <span style="color:#75715e">//出错时不在临界区，无需unlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">24</span>           <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">25</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">26</span>       new<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">27</span>    	<span style="color:#75715e">//just lock critical section !!!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">28</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">29</span>       new<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30</span>       L<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">31</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>       <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">33</span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">33</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">List_Lookup</span>(<span style="color:#66d9ef">list_t</span> <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>    	 <span style="color:#66d9ef">int</span> rv <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">// success / failure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">34</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">35</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>curr <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">36</span>       <span style="color:#66d9ef">while</span> (curr) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">37</span>           <span style="color:#66d9ef">if</span> (curr<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">38</span>               rv<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">39</span>               <span style="color:#66d9ef">break</span>; <span style="color:#75715e">// 跳出主循环，在主循环内统一unlock ！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">40</span>           }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">41</span>           curr <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">42</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">43</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>L<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">44</span>       <span style="color:#66d9ef">return</span> rv; <span style="color:#75715e">// now both success and failure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">45</span>   }
</span></span></code></pre></div><h2 id="扩展链表">扩展链表<a href="#扩展链表" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>过手锁<code>hand-overohand locking</code>: 每个节点都有一个锁，替代之前整个链表一个锁，遍历链表时，首先抢占下一个节点的锁，然后释放当前节点的锁
<ul>
<li>开销巨大，未必比单锁快</li>
</ul>
</li>
<li>注意控制流的变化导致函数返回和退出，这种情况下要<strong>记得释放锁</strong></li>
</ul>
<h2 id="并发队列">并发队列<a href="#并发队列" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>粗粒度的锁很简单，接下来使用细粒度的锁</p>
<ul>
<li>对队列头和尾各设置一个锁
<ul>
<li>因为出队只访问<code>head</code>锁， 入队只访问<code>tail</code>锁， 两把锁使得出队和入对可以并发执行</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">node_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>        <span style="color:#66d9ef">int</span>                 value;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>        <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">node_t</span>     <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>    } <span style="color:#66d9ef">node_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">queue_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>        <span style="color:#66d9ef">node_t</span>            <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>        <span style="color:#66d9ef">node_t</span>            <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>        <span style="color:#66d9ef">pthread_mutex_t</span>    headLock;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span>       <span style="color:#66d9ef">pthread_mutex_t</span>    tailLock;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span>   } <span style="color:#66d9ef">queue_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Queue_Init</span>(<span style="color:#66d9ef">queue_t</span> <span style="color:#f92672">*</span>q) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">14</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">node_t</span>));
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span>       tmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>       q<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>       <span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>headLock,  NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span>       <span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>tailLock,  NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Queue_Enqueue</span>(<span style="color:#66d9ef">queue_t</span> <span style="color:#f92672">*</span>q, <span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">node_t</span>));
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">23</span>       <span style="color:#a6e22e">assert</span>(tmp <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">24</span>       tmp<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">25</span>       tmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">26</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">27</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>tailLock);<span style="color:#75715e">//入队只访问`tail`锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">28</span>       q<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">29</span>       q<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>tailLock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">31</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">33</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Queue_Dequeue</span>(<span style="color:#66d9ef">queue_t</span> <span style="color:#f92672">*</span>q, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>value) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">34</span>       <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>headLock);<span style="color:#75715e">//出队只访问`head`锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">35</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">36</span>       <span style="color:#66d9ef">node_t</span> <span style="color:#f92672">*</span>newHead <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">37</span>       <span style="color:#66d9ef">if</span> (newHead <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">38</span>           <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>headLock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">39</span>           <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// queue was empty，这种写法（在子控制流unlock）很丑陋，应该像之前《重写并发链表》的 List_Lookup() 一样改造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">40</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">41</span>       <span style="color:#f92672">*</span>value <span style="color:#f92672">=</span> newHead<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">42</span>       q<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> newHead;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">43</span>       <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>headLock);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">44</span>       <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">45</span>       <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">46</span>   }
</span></span></code></pre></div><h2 id="并发散列表">并发散列表<a href="#并发散列表" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>每个元素都是一个并发链表，也称为“散列桶”
<ul>
<li>每个散列桶都有一个锁</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>    <span style="color:#960050;background-color:#1e0010">#</span>define <span style="color:#a6e22e">BUCKETS</span> (<span style="color:#ae81ff">101</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  <span style="color:#66d9ef">hash_t</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>        <span style="color:#66d9ef">list_t</span> lists[BUCKETS];
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>    } <span style="color:#66d9ef">hash_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Hash_Init</span>(<span style="color:#66d9ef">hash_t</span> <span style="color:#f92672">*</span>H) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> BUCKETS; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span>           <span style="color:#a6e22e">List_Init</span>(<span style="color:#f92672">&amp;</span>H<span style="color:#f92672">-&gt;</span>lists[i]);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span>       }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">14</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Hash_Insert</span>(<span style="color:#66d9ef">hash_t</span> <span style="color:#f92672">*</span>H, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span>       <span style="color:#66d9ef">int</span> bucket <span style="color:#f92672">=</span> key <span style="color:#f92672">%</span> BUCKETS;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>       <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">List_Insert</span>(<span style="color:#f92672">&amp;</span>H<span style="color:#f92672">-&gt;</span>lists[bucket], key);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>   }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Hash_Lookup</span>(<span style="color:#66d9ef">hash_t</span> <span style="color:#f92672">*</span>H, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20</span>       <span style="color:#66d9ef">int</span> bucket <span style="color:#f92672">=</span> key <span style="color:#f92672">%</span> BUCKETS;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span>       <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">List_Lookup</span>(<span style="color:#f92672">&amp;</span>H<span style="color:#f92672">-&gt;</span>lists[bucket], key);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>   }
</span></span></code></pre></div><h2 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>Knuth定律： <strong>避免不成熟的优化</strong>
<ul>
<li>先最简单的方案，也就是加大锁（ <code>big kernel lock, BKL. in linux kernel</code> ）开始， 如果有性能问题再改进</li>
</ul>
</li>
<li>控制流变化时记得获取和释放锁</li>
<li>增加并发并不一定能提高性能
<ul>
<li>过手锁</li>
</ul>
</li>
</ul>
<h1 id="conditional-variable">Conditional Variable<a href="#conditional-variable" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>
<p>条件变量： 一个显式<strong>队列</strong>， 当<code>condition</code>不满足时，线程把自己加入队列，<code>waiting</code>该条件。 当另外某个线程改变该<code>condition</code>时，就可以<strong>唤醒</strong><code>signal</code>一个或者多个（假唤醒）等待线程，让它们继续执行</p>
<ul>
<li>
<p><code>wait(  mutex )</code>: 该函数假定在<code>wait()</code>时， <code>mutex</code>是上锁状态。 <code>wait()</code>的职责是释放锁， 并让调用进程休眠（原子地）。 当线程被唤醒时（在另外某个线程<code>signal</code>它之后）它重新获取锁，再返回调用者</p>
<ul>
<li>
<p>这样使得<code>wait()</code>写起来很方便：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span>(done<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>c,<span style="color:#f92672">&amp;</span>m);<span style="color:#75715e">//wait释放锁，线程进入休眠。 当被signal时，wait获取锁，再返回调用者。 不用手写unlock\lock了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p>总结：<code>signal</code>和<code>wait</code>时总是持有锁 + 需要状态变量</p>
<ul>
<li><code>wait()</code>的语义强制要求调用时已经持有锁，因此不需要操心</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;mythreads.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> done <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pthread_mutex_t</span> m <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pthread_cond_t</span> c <span style="color:#f92672">=</span> PTHREAD_COND_INITIALIZER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_exit</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>     done <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_join</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span>(done<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">// 推荐使用while循环而不是if,原因之后解释
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>c,<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">child</span>( <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;child</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">thr_exit</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>( <span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span>  p;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;parent: begin</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_create</span>(<span style="color:#f92672">&amp;</span>p, NULL,child, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">thr_join</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;parent: end</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>情况一： parent创建出子进程后，自己继续运行（假设单核），然后马上调用<code>thr_join()</code> 等待子进程，此时它会先获取锁，检查子进程是否完成（还没有），然后调用<code>wait()</code>，让自己休眠。 子线程最终得以运行，打印出“child”， 并调用<code>thr_exit()</code>唤醒父进程， 而<code>exit()</code>原子地设置<code>done</code>，向父进程<code>signal</code>， 最后父进程会运行，从<code>wait()</code>返回并持有锁， 释放锁， 打印出“parent: end”</li>
<li>情况二：子进程创建后立刻运行， 设置<code>done = 1</code>， 调用<code>signal()</code>唤醒其他线程（这里没有其他线程），然后结束。 副进程运行后，调用<code>thr_join()</code>时，发现<code>done</code>已经为1了，就直接返回</li>
</ul>
<pre tabindex="0"><code>parent: begin
child
parent: end
</code></pre><ul>
<li>
<p>状态变量<code>done</code>是<strong>必要</strong>的</p>
<p>假如没有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_exit</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_join</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>c,<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><ul>
<li>假如子线程立刻运行，且调用<code>thr_exit</code>，此时子进程<code>signal()</code>，条件变量上没有睡眠的线程。 父线程运行时，就会调用<code>wait（）</code>并卡在这里，没有线程会<code>signal（）</code>它</li>
</ul>
</li>
<li>
<p>发信号和等待时加锁也是必要的</p>
<p>假如没有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_exit</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     done <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_join</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span>(done<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">// 推荐使用while循环而不是if,原因之后解释
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>c,<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><ul>
<li>如果父进程调用<code>thr_join()</code>,检查<code>done = 0</code>，试图睡眠，然而在调用<code>wait（）</code>前被中断（因为没有锁，此时其它进程就可以操纵临界区）， 子进程修改变量为1,发出<code>signal（）</code>，此时没有睡眠进程。 父进程再次运行时，就会卡在<code>wait()</code>，没有线程可以唤醒它</li>
</ul>
</li>
</ul>
<h2 id="生产者消费者有界缓冲区问题">生产者/消费者（有界缓冲区）问题<a href="#生产者消费者有界缓冲区问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//30_7.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">cond_t</span> cond;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mutex_t</span> mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>cond,<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">put</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>cond);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);       
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>( count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )<span style="color:#75715e">//必须用while,不能用if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>cond,<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>cond);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ptrintf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>假设使用<code>if</code>:  假设有两个消费者$T_{c1}$和，$T_{c2}$ 生产者$T_{p}$,
<ul>
<li>若$T_{c1}$先运行，卡在<code>wait</code>， 接着$T_p$运行，在缓冲区放一个数字，然后<code>signal</code>唤醒$T_{c1}$， 生产者继续循环，直到发现缓冲区满后睡眠</li>
<li>此时如果$T_{c2}$抢先执行，消费了缓冲区里的值，然后$T_{c1}$从<code>wait</code>处恢复运行，调用<code>get</code>，此时发生error！</li>
<li>原因在于，生产者<code>signal</code>唤醒了$T_{c1}$， 但是没有保证$T_{c1}$立即执行 （或者说，没有保证$T_{c1}$执行之前，缓冲区没有再发生变化）
<ul>
<li><code>signal</code>的这种语义称为<code>Mesa</code>语义</li>
</ul>
</li>
</ul>
</li>
<li>解决方案是： <strong>始终使用<code>while</code></strong>，这样当$T_{c1}$醒来时，会再次检查<code>count==0</code>，发现为缓冲区0则继续<code>wait</code>。这样就避免了error</li>
</ul>
<h3 id="使用两个条件变量">使用两个条件变量<a href="#使用两个条件变量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>上述代码依然有问题： 假设$T_{c1}$和$T_{c2}$先运行，都卡在<code>wait</code>， $T_{p}$开始运行，往缓冲区放入一个值，发出<code>signal</code>， 继续循环，直到发现缓冲区满后睡眠</li>
<li>$T_{c1}$醒来，消费了这个值，然后在该条件上<code>signal</code>，注意，此时理应唤醒$T_{p}$， 但事实上有可能唤醒$T_{c2}$</li>
<li>假如唤醒$T_{c2}$，因为缓冲区为空， 它会卡在<code>wait</code>，<strong>此时三个线程都处于睡眠</strong></li>
<li>原因在于， <strong><code>signal</code>没有指向性</strong>， 消费者不应唤醒消费者，只应该唤醒生产者</li>
<li>解决方案：使用两个条件变量， 生产者睡在<code>empty</code>， 消费者睡在<code>fill</code>
<ul>
<li>由此也看出，<strong>线程唤醒需要满足什么条件，它就应该睡在哪个条件变量上</strong>，这是<strong>条件变量的命名方式</strong>
<ul>
<li>比如消费者需要缓冲区<code>fill</code>才能醒来，因此该条件变量就命名为<code>fill</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//30_8.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">cond_t</span> empty,fill;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mutex_t</span> mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>empty,<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">put</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);       
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>( count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>fill,<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ptrintf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="最终版本">最终版本<a href="#最终版本" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ul>
<li>这是最终版本，生产者只有缓冲区满了的时候才会睡眠
<ul>
<li>因此信号量命名为<code>empty</code>有点名不符实（ <code>fill</code>也是如此，事实上缓冲区有一个值就可以唤醒消费者了 ）</li>
<li>对<code>get()</code>和<code>put()</code>的调用保证上了锁</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//30_9.c  生产者消费者问题最终版
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> buffer[MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fill_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> use_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    buffer[fill_ptr] <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    fill_ptr <span style="color:#f92672">=</span> (fill_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>()<span style="color:#75715e">//拿取use_ptr指向的值，use_ptr++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> buffer[use_ptr];
</span></span><span style="display:flex;"><span>    use_ptr <span style="color:#f92672">=</span> (use_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">cond_t</span> empty,fill;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mutex_t</span> mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">==</span> MAX)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>empty,<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">put</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);       
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>( count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pthread_cond_wait</span>(<span style="color:#f92672">&amp;</span>fill,<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_signal</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ptrintf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="覆盖条件">覆盖条件<a href="#覆盖条件" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li><code>signal</code>只会唤醒一个线程</li>
<li>考虑一个内存分配程序。 当没有空闲内存时， $T_{c1}$和$T_{c2}$各自<code>allocate</code>1000和10字节。 它们都因此卡在<code>wait</code>
<ul>
<li>此时$T_{p}$ <code>free</code>了50字节，它发出signal，此时有可能唤醒的是$T_{c1}$， 后者因为内存不够，依然继续睡眠</li>
<li>上述代码因此无法正常工作</li>
</ul>
</li>
<li>解决方案是采用广播的signal, 即<code>pthread_cond_broadcast()</code> 代替<code>pthread_cond_signal</code>,唤醒所有等待线程，这个条件变量称为<strong>广播条件<code>covering condition</code></strong>
<ul>
<li>会影响性能</li>
<li>该方案虽然很笨，但有时很有用</li>
<li>当然，<code>30_8.c</code>的代码也可以采用此解决方案。 但我当时有更好的办法（用两个条件变量）</li>
</ul>
</li>
</ul>
<h1 id="信号量">信号量<a href="#信号量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>
<p>def： 有一个整数值的对象，可以用<code>sem_wait()</code>和<code>sem_post()</code>操作（ in Posix ）</p>
<ul>
<li>因此要初始化</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;semaphore.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">sem_t</span> s;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>s, <span style="color:#ae81ff">0</span> , <span style="color:#ae81ff">0</span>); <span style="color:#960050;background-color:#1e0010">第二个参数一般设为</span><span style="color:#ae81ff">0</span>,<span style="color:#960050;background-color:#1e0010">表示该信号量在同一个进程的多个线程内贡献</span>
</span></span></code></pre></div></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sem_wait</span>(<span style="color:#66d9ef">sem_t</span> <span style="color:#f92672">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//decrement the value of semaphore s by one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//wait if value of semaphore s is a negative
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sem_post</span>(<span style="color:#66d9ef">sem_t</span> <span style="color:#f92672">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//increment the value of semaphore s by one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//if there are one or more threads waiting, wake one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>
<p>在这个实现中， 信号量的值为负数时，该值就是等待线程的个数</p>
</li>
<li>
<p><strong>信号量有时很难设计，此时还是使用条件变量更靠谱</strong></p>
</li>
</ul>
<h2 id="二值信号量锁">二值信号量（锁）<a href="#二值信号量锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>可以把信号量作为锁(<strong>其值设为1</strong>)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">sem_t</span> m;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>m, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">//下文解释为何是1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//critical section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>m);
</span></span></code></pre></div><ul>
<li>假设有两个线程，$T_{1}$调用<code>sem_wait()</code>，将信号量值减为0, 因为0不是负数，因此$T_{c1}$从<code>wait</code>返回并继续，它可以自由进入临界区， 若没有其他线程尝试获取锁，当$T_{1}$调用<code>sem_post()</code>时，会将信号重置为1</li>
<li>如果$T_{1}$持有锁时，$T_{2}$尝试获取锁（即调用<code>sem_wait()</code>），此时它会将信号量减为<code>-1</code>。然后卡在这里。 $T_{1}$再次运行，执行<code>sem_post()</code>，  将信号量值增加到0,唤醒等待的线程（$T_{2}$），然后$T_{2}$就能获取锁
<ul>
<li>当$T_{2}$执行结束时，执行<code>sem_post()</code>，  将信号量值增加到1</li>
</ul>
</li>
</ul>
<h2 id="信号量用作条件变量">信号量用作条件变量<a href="#信号量用作条件变量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">sem_t</span> s;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">child</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;child</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>s);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>( <span style="color:#f92672">&amp;</span>s, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> );<span style="color:#75715e">//信号量设为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;parent: begin</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_create</span>(c, NULL, child, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>s); <span style="color:#75715e">// wait here for child
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;parent: end</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出为：</p>
<pre tabindex="0"><code>parent: begin
child
parent: end
</code></pre><ul>
<li>考虑两种情况：
<ol>
<li>子进程没有先运行，父进程先调用<code>sem_wait()</code>,将信号量减为-1,父进程卡在<code>wait</code>， 然后子进程运行，调用<code>sem_post()</code>，信号量增加为0,唤醒父线程</li>
<li>子线程在父线程调用<code>sem_post()</code>之前就运行结束，结果正常</li>
</ol>
</li>
</ul>
<h2 id="生产者消费者有界缓冲区问题-1">生产者/消费者（有界缓冲区）问题<a href="#生产者消费者有界缓冲区问题-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>考虑用信号量实现生产者/消费者问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> buffer[MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fill_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> use_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    buffer[fill_ptr] <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    fill_ptr <span style="color:#f92672">=</span> (fill_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>()<span style="color:#75715e">//拿取use_ptr指向的值，use_ptr++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> buffer[use_ptr];
</span></span><span style="display:flex;"><span>    use_ptr <span style="color:#f92672">=</span> (use_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sem_t</span> empty,fill;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// mutex_t mutex;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">put</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ptrintf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>这段代码的问题在于： 对假设MAX大于1,此时可以有两个生产者（$T_1$, $T_2$）同时调用<code>put()</code>，如果$T_1$先放入数据，然后在更新计时器时中断，$T_2$运行，它会在该位置再放入一个值，发生error
<ul>
<li>这是因为在MAX&gt;1时，信号量的使用不能保证<code>put（）</code>的原子性</li>
</ul>
</li>
<li>解决方案：上锁</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> buffer[MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fill_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> use_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    buffer[fill_ptr] <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    fill_ptr <span style="color:#f92672">=</span> (fill_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>()<span style="color:#75715e">//拿取use_ptr指向的值，use_ptr++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> buffer[use_ptr];
</span></span><span style="display:flex;"><span>    use_ptr <span style="color:#f92672">=</span> (use_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sem_t</span> empty,fill,mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">put</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ptrintf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>empty, <span style="color:#ae81ff">0</span>, MAX);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>fill, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>mutex, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);<span style="color:#75715e">// mutex = 1 because it is a lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>
<p>这段代码依然有问题： 因为在<code>fill</code>和<code>empty</code>上睡着时没有释放锁（传统的<code>pthread_wait</code>是会释放锁的，但是这里是用信号量实现的锁）。 因此消费者在<code>fill</code>上睡着时，二值信号量锁<code>mutex</code>没有释放，生产者试图对<code>mutex</code>调用<code>sem_wait</code>也被卡住。</p>
<ul>
<li>消费者等待在<code>full</code>，持有<code>mutex</code>， 生产者可以signal <code>fill</code>，却在等待<code>mutex</code>，发生了<strong>死锁</strong></li>
</ul>
</li>
<li>
<p>解决方案： 把对<code>mutex</code>的获取和释放调整为紧挨着临界区</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> buffer[MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fill_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> use_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    buffer[fill_ptr] <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    fill_ptr <span style="color:#f92672">=</span> (fill_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>()<span style="color:#75715e">//拿取use_ptr指向的值，use_ptr++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> buffer[use_ptr];
</span></span><span style="display:flex;"><span>    use_ptr <span style="color:#f92672">=</span> (use_ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MAX;
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sem_t</span> empty,fill,mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">put</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>fill)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>empty);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ptrintf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>empty, <span style="color:#ae81ff">0</span>, MAX);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>fill, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>(<span style="color:#f92672">&amp;</span>mutex, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);<span style="color:#75715e">// mutex = 1 because it is a lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="读者-----写者锁">读者 &mdash; 写者锁<a href="#读者-----写者锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>读写锁更加灵活，因为查找操作不会更改临界区</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _rwlock_t
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sem_t</span> lock; <span style="color:#75715e">// binary sephamore, basic lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sem_t</span> writelock;<span style="color:#75715e">//used to allow ONE writer or MANY readers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> readers;<span style="color:#75715e">// count of readers reading in critical section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}<span style="color:#66d9ef">rwlock_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rwlock_init</span>( <span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>rw )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    rw <span style="color:#f92672">-&gt;</span> readers <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>( <span style="color:#f92672">&amp;</span>rw <span style="color:#f92672">-&gt;</span> lock, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_init</span>( <span style="color:#f92672">&amp;</span>rw <span style="color:#f92672">-&gt;</span> writelock, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rwlock_acquire_readlock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>rw)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>rw<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>    rw <span style="color:#f92672">-&gt;</span> readers<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(rw<span style="color:#f92672">-&gt;</span>readers <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>( <span style="color:#f92672">&amp;</span>rw <span style="color:#f92672">-&gt;</span>writelock ); <span style="color:#75715e">// last reader releases writelock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>rw <span style="color:#f92672">-&gt;</span> lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rwlock_release_readlock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>rw)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>rw<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>    rw <span style="color:#f92672">-&gt;</span> readers<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>( rw <span style="color:#f92672">-&gt;</span> readers <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sem_post</span>( rw <span style="color:#f92672">-&gt;</span> writelock );<span style="color:#75715e">// last reader releases writelock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>rw<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rwlock_acquire_writelock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>rw)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_wait</span>(<span style="color:#f92672">&amp;</span>rw<span style="color:#f92672">-&gt;</span> writelock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rwlock_release_writelock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>rw )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sem_post</span>(<span style="color:#f92672">&amp;</span>rw <span style="color:#f92672">-&gt;</span> writelock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>想要获取写锁的进程，需要等待所有的读者都结束</li>
<li>缺点：读者很容易饿死写者</li>
</ul>
<h2 id="哲学家就餐问题">哲学家就餐问题<a href="#哲学家就餐问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>最简单的解决方案：破除依赖， 就是修改某个哲学家的取餐叉顺序</p>
<h2 id="如何实现信号量">如何实现信号量<a href="#如何实现信号量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>用锁和条件变量实现信号量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;mythreads.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;semaphore.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _Zem_t{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_cond_t</span> cond;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_mutex_t</span> lock;
</span></span><span style="display:flex;"><span>}Zem_t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//only one thread can call this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Zem_init</span>(Zem_t <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">-&gt;</span> value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_cond_init</span>(<span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>cond,NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>lock,NULL);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Zem_wait</span>(Zem_t <span style="color:#f92672">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>( s<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pthread_cond_wait</span>( <span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>cond, <span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>lock );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">-&gt;</span>value<span style="color:#f92672">--</span>;<span style="color:#75715e">//注意到这里是先检查是否为非正数，再递减
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Zem_post</span>(Zem_t <span style="color:#f92672">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">-&gt;</span> value<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_cond_signal</span>( <span style="color:#f92672">&amp;</span>s <span style="color:#f92672">-&gt;</span> cond );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>注意到<code>wait</code>是先检查是否为非正数，再递减，这使得信号量值永远不会小于0
<ul>
<li>这也是linux的实现</li>
</ul>
</li>
<li>用信号量来实现锁和条件变量相当困难</li>
</ul>
<h1 id="常见并发问题">常见并发问题<a href="#常见并发问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="非死锁缺陷">非死锁缺陷<a href="#非死锁缺陷" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>
<p>违反原子性缺陷：给共享变量的访问加锁</p>
</li>
<li>
<p>违反顺序缺陷：使用条件变量，强制顺序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>( inited <span style="color:#f92672">==</span> <span style="color:#f92672">=</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pthread_Cond_wait</span>( <span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex );
</span></span><span style="display:flex;"><span><span style="color:#75715e">//operations to critical section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>mutex);
</span></span></code></pre></div></li>
</ul>
<h2 id="死锁缺陷">死锁缺陷<a href="#死锁缺陷" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>模块化和锁不是很契合</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>T1</th>
<th>T2</th>
<th>T3</th>
<th>T4</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>L2</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
<ul>
<li>系统形成死锁的四个必要条件
<ol>
<li>互斥条件(mutual exclusion):系统中存在临界资源,进程应互斥地使用这些资源</li>
<li>占有和等待条件(hold and wait):进程请求资源得不到满足而等待时,不释放已占有的资源</li>
<li>不剥夺条件(no preemption):已被占用的资源只能由属主释放,不允许被其它进程剥夺</li>
<li>循环等待条件(circular wait):存在循环等待链,其中,每个进程都在链中等待下一个进程所持有的资源,造成这组进程永远等待</li>
</ol>
</li>
</ul>
<h3 id="循环等待">循环等待<a href="#循环等待" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>细致地设计锁策略，有序加锁</li>
</ul>
<h3 id="持有并等待">持有并等待<a href="#持有并等待" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>任何线程抢锁之前要先抢一个全局锁，这样保证了抢锁的原子性(抢锁时不会有其他进程切入)
<ul>
<li>如：假如线程1需要<code>lock1</code>和<code>lock2</code>， 而线程二需要<code>lock2</code>和<code>lock1</code>。线程1获得<code>lock1</code>后不会被打断，能继续获得<code> lock2</code>，执行完毕，释放这两个锁，线程二继续执行。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">lock</span>(prevection);<span style="color:#75715e">//global lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lock</span>(L1);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lock</span>(L2);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">unlock</span>(prevention);
</span></span></code></pre></div><h3 id="非抢占">非抢占<a href="#非抢占" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> top:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>(L1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">trylock</span>(L2)<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">unlock</span>(L1);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span>(top);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span></code></pre></div><ul>
<li>同样是实现了原子地抢占锁
<ul>
<li>如果<code>L2</code>没抢到，那么会释放<code>L1</code></li>
</ul>
</li>
<li>会导致活锁（ <code>livelock</code>）
<ul>
<li>两个线程可能一直重复这一序列，又同时都抢锁失败
<ul>
<li>假如线程1持有<code>lock1</code>，等待<code>lock2</code>( 因此该线程一直try - fail)， 而线程二持有<code>lock2</code>，等待<code>lock1</code>,线程1在试图获得<code>lock2</code>时被中断，线程2获得<code>lock2</code>，试图获得<code>lock1</code>，此时发生活锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="互斥">互斥<a href="#互斥" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>通过无等待（wait-free）数据结构避免互斥</li>
</ul>
<h3 id="通过调度避免死锁">通过调度避免死锁<a href="#通过调度避免死锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>线程对锁的需求：</p>
<table>
<thead>
<tr>
<th></th>
<th>T1</th>
<th>T2</th>
<th>T3</th>
<th>T4</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>L2</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
<ul>
<li>只要T1和T2不同时运行就不会发生死锁
<ul>
<li>T3只用到一把锁，因此可以和其它线程并发执行，不会死锁</li>
</ul>
</li>
<li>可以强制T2在T1之后运行</li>
<li>这种保守的方案很明显会降低性能</li>
</ul>
<h3 id="检查和恢复">检查和恢复<a href="#检查和恢复" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>允许死锁偶尔发生，检查到死锁时再采取行动（重启电脑）</li>
<li>太摆烂了。。。</li>
</ul>
<h1 id="基于事件的并发advanced">基于事件的并发（Advanced）<a href="#基于事件的并发advanced" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>事件循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    events <span style="color:#f92672">=</span> <span style="color:#a6e22e">getEvents</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( e in events )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">processEvent</span>(e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>因为事件是原子的，一次只处理一个事件不需要考虑线程切换。 而且如上所见，我们可以对事件调度进行<strong>显式控制</strong></li>
<li>这意味着事件是阻塞的，有巨大的性能开销，需要引入异步的事件处理，再加上多CPU时，并行的事件处理复杂度相当于多线程。 因此给予事件的并发并不比基于线程的简单。</li>
<li>这部分内容很庞大，我不想在C编程上倾注太多时间，因此放在JAVA等语言的并发中讲。</li>
</ul>
      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://lyk-love.cn/Hugo-Blog/posts/l2-asymptotics/">
                <span class="button__icon">←</span>
                <span class="button__text">L2 Asymptotics3000</span>
            </a>
        </span>
        
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2023 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/Hugo-Blog/bundle.min.js"></script>



<a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
  <span class="icon-search">Search</span>
</a>











<script>
  
  
  
  
  var search_page_relative_url = "/search"
  
  
  
  document.addEventListener('keydown', function(event) {

    
    if (event.altKey && event.which === 191) {
      
      
      navToSearchPage(event)
    }

    
    if (event.keyCode == 27) {
      navToHomePage()
    }
  });


  document.querySelector("#search-btn").onclick = function(e) {
    e.stopPropagation();
    navToSearchPage()
  }


  function navToHomePage() {
    window.location.href = "/"
  }

  function navToSearchPage() {
    window.location.href = search_page_relative_url
    
    
    
  }
</script>



<div class="footer-box">
  
  <div class="back-to-top" id="back_to_top">
    
    
    
    <span><i class="fas fa-arrow-up"></i></span> 
    
    <span class="scrollpercent">
            <span id="back_to_top_text">0</span>%
         </span>
  </div>
</div>
<script>
  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
          back2TopText = document.querySelector('#back_to_top_text'),
          drawerBox = document.querySelector('#drawer_box'),
          rightSideBar = document.querySelector('.sidebar'),
          viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });
  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }
</script>


  
</div>


</body>
</html>
